<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MYSQL之数据表级联操作-数据完整性约束]]></title>
    <url>%2F2018%2F07%2F15%2Fmysql_key%2F</url>
    <content type="text"><![CDATA[外键约束 目前mysql只有InnoDB存储引擎支持外键约束 column_name 当前表外键字段名 table_name 外键表 index_column_name 外键所在外键表中字段名 ON DELETE 删除 ON UPDATE 更新 reference_option语法格式为：（没设置时候，默认两个都指定 RESTRICT） 当删除或更新外键所在外键表的数据时候 RESTRICT 限制策略，系统不删除或更新外键当前表的数据 CASCADE 级联策略，自动删除或更新外键当前表的数据 SET FULL 置空策略，设置外键当前表的数据外键列数据为NULL，需要提前设置外键列未被限制 NOT NULL NO ACTION 不采取实施策略，系统不删除或更新外键当前表的数据，与 RESTRICT 一致 12345FOREIGN KEY ( column_name [(length)] [ASC | DESC] ) REFERENCES table_name(index_column_name)[MATCH FULL | MATCH PARTIAL | MATCH SIMPLE][ON DELETE reference_option][ON UPDATE reference_option] 创建表，关联外键12345678910111213141516// 创建 班级表create table if not exists class( id int(11) not null auto_increment, name varchar(30) not null, primary key (id)) ENGINE=InnoDB default charset=utf8;// 创建学生表，外键 班级id class_id，级联删除及更新create table if not exists student( id int(11) not null auto_increment, name varchar(30) not null, class_id int(11) not null, primary key(id), index(class_id), foreign key (class_id) references class(id) on delete cascade on update cascade) ENGINE=InnoDB default charset=utf8; 插入数据操作1234567891011//插入数据insert into class(name) values(&apos;one&apos;), (&apos;two&apos;), (&apos;three&apos;);// 生成 id 1,2,3insert into student(class_id,name) values(1, &apos;lili&apos;);insert into student(class_id,name) values(2, &apos;lili&apos;);insert into student(class_id,name) values(2, &apos;lili&apos;);insert into student(class_id,name) values(3, &apos;lili&apos;);// 插入失败，因为班级表中没有id =10的数据insert into student(class_id,name) values(10, &apos;lili&apos;); 更新数据操作123//更新数据update class set id=5 where id=2;//此时 学生表中 sid=2的数据同步更新为了5 删除数据操作123//删除数据delete from class where id=1;//此时 学生表中 sid=1的数据同步删除了 主键 一个表中有且只有一个主键 123456789101112// 单字段主键create table if not exists table_test( id int(11) not null auto_increment primary key, name varchar(30) not null) engine=InnoDB default charset=utf8;// 复合字段主键create table if not exists table_test( id int(11) not null auto_increment, name varchar(30) not null, primary key(id, name)) engine=InnoDB default charset=utf8; 候选键 一个表中可以存在多个候选键UNIQUE 来表示 1234create table if not exists table_test( id int(11) not null auto_increment UNIQUE, name varchar(30) not null UNIQUE,) engine=InnoDB default charset=utf8; 字段条件约束12345678910// nullid int(11) not null,sid int(11) null// check对列约束age int(2) not null check(age&gt;6 and age&lt;18)// check对表约束primary key(id),check(class_id in (select id from tb_class)) 完整性约束12345678910// 创建表的时候使用constraint &lt;symbol&gt;[primary ... | foreign ... | check ...]// 更新表的完整性约束alter table table_name add constraint primaryprimary key(id)// 删除表的完整性约束alter table table_name drop [foreign key|index] &lt;symbol&gt; [primary key]]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL之索引]]></title>
    <url>%2F2018%2F07%2F15%2Fmysql_index%2F</url>
    <content type="text"><![CDATA[索引的两种存储类型：B树(BTree)索引、哈希(Hash)索引BTree为系统默认索引 创建表时建立索引1234create table ( 属性名 长度 是否为空, [UNIQUE | FULLTEXT | SPATIAL ] INDEX|KEY [别名]( 属性名1 [(长度)] [ASC | DESC])) 已建立的表中创建索引1create [UNIQUE | FULLTEXT | SPATIAL ] INDEX [别名] on table_name( 属性名1 [(长度)] [ASC | DESC]) 修改表结构添加索引1alter table table_name add [UNIQUE | FULLTEXT | SPATIAL ] INDEX [别名] on table_name( 属性名1 [(长度)] [ASC | DESC]) 删除索引1drop INDEX 属性名 on table_name []是可选项 [UNIQUE | FULLTEXT | SPATIAL ] 可选项，分别代表唯一性索引、全文索引、空间索引 INDEX和KEY参数其中一个即可，用于指定字段索引 别名为可选项，创建的索引取新名称 别名的参数如下： 属性名1 必选项，指索引对应的字段名称，该字段必须预选被定义到表中 长度 可选项，索引的长度，必须是字符串类型才可以使用 ASC/DESC可选项，ASC表示升序排列，DESC表示降序排列 table_name 表名称 普通索引 在任何数据类型的字段中创建索引 12345678910111213// 创建表的时候创建索引// 创建了索引列 idcreate table if not exists table_test( id int(11) not null auto_increment primary key, name varchar(30) not null, index(id));// 已存在表中创建索引create index info on table_test (id)// 修改表结构添加索引alter table table_test add index info (id)// 查看表结构show create table table_test; 唯一性索引 使用UNIQUE参数设置唯一索引，该索引的值必须唯一主键是一种特殊的唯一索引 12345678910111213// 创建表的时候创建索引// 创建唯一索引 别名为 name 索引字段为 id，索引存储排序为 asccreate table if not exists table_test( id int(11) not null auto_increment primary key, name varchar(30) not null, UNIQUE INDEX name (id asc));// 已存在表中创建索引create UNIQUE INDEX name on table_test (id asc)// 修改表结构添加索引alter table table_test add UNIQUE INDEX name (id asc)// 查看表结构show create table table_test; 全文索引 使用FULLTEXT参数设置全文索引只有myisam存储引擎的数据表支持fulltext全文索引只能创建在数据类型为 char、varchar、text的字段上默认情况下，应用全文索引大小写不敏感，索引的列使用二进制排序后，可以执行大小写敏感的全文索引 12345678910111213// 创建表的时候创建索引// 创建全文索引 别名为 name_info 索引字段为 namecreate table if not exists table_test( id int(11) not null auto_increment primary key, name varchar(30) not null, FULLTEXT KEY name_info (name)) engine=MyISAM;// 已存在表中创建索引create FULLTEXT INDEX name_info on table_test (name)// 修改表结构添加索引alter table table_test add FULLTEXT INDEX name_info (name)// 查看表结构show create table table_test; 单列索引 只对应一个字段的索引 1234567891011121314// 创建表的时候创建索引// 创建单列索引 别名为 name_info 索引字段为 name，索引字段长度为20// 数据表中的字段长度为30，而创建的索引的字段长度为20，这样做的目的是为了提高查询效率，优化查询速度create table if not exists table_test( id int(11) not null auto_increment primary key, name varchar(30) not null, INDEX name_info (name(20)));// 已存在表中创建索引create INDEX name_info on table_test (name(20))// 修改表结构添加索引alter table table_test add INDEX name_info (name(20))// 查看表结构show create table table_test; 多列索引 表的多个字段上创建索引应用此索引，必须使用这些字段的第一个字段 1234567891011121314// 创建表的时候创建索引// 创建多列索引 别名为 info 索引字段为 name、sexcreate table if not exists table_test( id int(11) not null auto_increment primary key, name varchar(30) not null, sex bit(1) not null, INDEX info (name,sex));// 已存在表中创建索引create INDEX info on table_test (name,sex)// 修改表结构添加索引alter table table_test add INDEX info (name,sex)// 查看表结构show create table table_test; 空间索引 使用SPATIAL参数可以设置空间索引只能建立在数据类型为空间类型的字段上mysql只有MyISAM存储引擎支持空间检索，且索引的字段不能为空值空间类型：geometry、point、linestring、polygon 12345678910111213// 创建表的时候创建索引// 创建空间索引 别名为 good_info 索引字段为 goodcreate table if not exists table_test( id int(11) not null auto_increment primary key, good geometry not null, SPATIAL INDEX good_info (good));// 已存在表中创建索引create SPATIAL INDEX good_info on table_test (good)// 修改表结构添加索引alter table table_test add SPATIAL INDEX good_info (good)// 查看表结构show create table table_test;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL之流程控制语句]]></title>
    <url>%2F2018%2F07%2F07%2Fmysql_condition%2F</url>
    <content type="text"><![CDATA[if、case、loop、while、iterate、leave if 注意 分号不能省略 1234567IF CONDITION THEN ...;ELSEIF CONDITION THEN ...;ELSE ...;END IF; 123456789101112调用：call do_if(10)CREATE PROCEDURE do_if(in x int)BEGINIF x IS NULL THEN select 100;ELSEIF x=0 THEN select 101;ELSE select 102;END IF;END case 注意 分号不能省略 12345CASE valueWHEN value THEN ...;WHEN value THEN ...;ELSE ...;END CASE; 12345678910调用：call do_case(10)CREATE PROCEDURE do_case(in x int)BEGINCASE xWHEN x IS NULL THEN SELECT 100;WHEN x = 0 THEN SELECT 101;ELSE SELECT 102;END CASE;END while 注意 分号不能省略 123WHILE CONDITION DO ...;END WHILE; 1234567891011121314调用： call do_while(@sum) select @sumCREATE PROCEDURE do_while(out x int)BEGINDECLARE i int DEFAULT 1;DECLARE j int DEFAULT 0;WHILE i&lt;100 DO set j=j+i; set i=i+1;END WHILE;SET x=j;END loop 注意 分号不能省略LEAVE loop_label 退出 定义名称为loop_label的loop退出循环 123LOOP ...END LOOP; 1234567891011121314151617调用： call do_loop(@sum) select @sumCREATE PROCEDURE do_loop(out x int)BEGINDECLARE i int DEFAULT 1;DECLARE j int DEFAULT 0;loop_label:LOOP set j=j+i; set i=i+1; IF i&gt;10 THEN LEAVE loop_label; END IF;END LOOP;set x=j;END repeat 注意 分号不能省略 1234REPEAT ...UNTIL CONDITIONEND REPEAT; 123456789101112131415调用： call do_repeat(@sum) select @sumCREATE PROCEDURE do_repeat(out x int)BEGINDECLARE i int DEFAULT 1;DECLARE j int DEFAULT 0;REPEATset j=j+i;set i=i+1;UNTIL i&gt;10END REPEAT;set x=j;END]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL之运算符操作]]></title>
    <url>%2F2018%2F07%2F07%2Fmysql_calculate%2F</url>
    <content type="text"><![CDATA[1234create table if not exists test( id int(11) not null auto_increment primary key, num int(11) null) 算术运算符 加(+)、减(-)、乘(*)、除(/)、余(%)、除(div)、余(mod) 123456select id, num, id+num, id-num, id*num, id/num, id%num, id div num, id mod num from test;结果：id num id+num id-num id*num id/num id%num id div num id mod num5 2 8 3 10 2.5 1 2 16 null null null null null null null nullnull 5 null null null null null null null 比较运算符 大于(&gt;)、小于(&lt;)、等于(=)、不等于(!=或&lt;&gt;)、大于等于(&gt;=)、小于等于(&lt;=) 1234561. 符合条件的结果为12. 不符合条件的结果为03. 值为NULL的结果为null``` &gt;是null(IS NULL)、不是null(IS NOT NULL) 判断是否为空值可以采用 &lt;=&gt; 进行判断，a&lt;=&gt;0，值为0的结果为1，其他都为0；a&lt;=&gt;null，值为null的结果为1，其他都为01234&gt;包含(between a and b) &gt;包含(id IN (1,2,3))、不包含(id not in(1,2,3)) &gt;模式匹配(name like &apos;%keyword%&apos;)、模式不匹配(name not like &apos;%keyword%&apos;) like ‘abc’ 表示字符串=abc的匹配 like ‘%abc’ 表示以abc结尾的字符串匹配 like ‘abc%’ 表示以abc开头的字符串匹配 like ‘%abc%’表示包含abc的字符串匹配 12&gt;正则匹配(a regexp &apos;^a&apos;) a regexp ‘^abc’ 表示以abc开头的字符串匹配 a regexp ‘abc’ 表示包含abc的字符串匹配 a regexp ‘abc$’ 表示以abc结尾的字符串匹配 123### 逻辑运算符&gt;与(&amp;&amp;或AND)、或(||或OR)、非(!或NOT)、异或(XOR) &amp;&amp; 只要有一个值为0，结果为0；有值为null，其他都不为0，结果为null；值都不为null与0的结果为1； || 值都为0结果为0；值为0或者null结果为null；值存在不为0或者null的结果为1； ! 值为null结果为null；值为0的结果为1；值为非0或null的结果为1； XOR 值存在null的结果为null；值都是非0或者都是0的结果为0；值存在0跟非0的结果为1； 123### 位运算符&gt;按位与(&amp;)、按位或(|)、按位取反(~)、按位异或(^)、按位左移(&lt;&lt;)、按位右移(&gt;&gt;) &amp; 将十进制数转换为二进制数，每个二进制数对应的位上进行与运算，最后转换为十进制数 例：10&amp;5 =&gt; 1010&amp;0101 =&gt; 0000 =&gt; 0 例：10&amp;6 =&gt; 1010&amp;0110 =&gt; 0010 =&gt; 2 | 将十进制数转换为二进制数，每个二进制数对应的位上进行或运算，最后转换为十进制数 例：10&amp;5 =&gt; 1010|0101 =&gt; 1111 =&gt; 15 例：10&amp;6 =&gt; 1010|0110 =&gt; 1110 =&gt; 14 ~ 将十进制数转换为二进制数，每位都进行取反运算 例：10 =&gt; 1010 =&gt; 0101 =&gt; 18446744073709551605(字节计算结果) ^ 将十进制数转换为二进制数，每个二进制数对应的位上进行异或运算，最后转换为十进制数 例：10&amp;5 =&gt; 1010^0101 =&gt; 1111 =&gt; 15 例：10&amp;6 =&gt; 1010^0110 =&gt; 1100 =&gt; 12 &lt;&lt; m &lt;&lt; n 将十进制数m转换为二进制数，按位左移n位，右边补上n个0，最后转换为十进制数 例：10 &lt;&lt; 1 =&gt; 1010 =&gt; 10100 =&gt; 20 m &gt;&gt; n 将十进制数m转换为二进制数，按位右移n位，左边补上n个0，最后转换为十进制数 例：10 &gt;&gt; 1 =&gt; 1010 =&gt; 0101 =&gt; 5` 运算符优先级]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL之操作数据（增删改查）]]></title>
    <url>%2F2018%2F07%2F07%2Fmysql_dba%2F</url>
    <content type="text"><![CDATA[数据表结构1234567$sql = ` create table if not exists table_test( id int(11) not null auto_increment primary key, name varchar(30) not null, sex tinyint(1) null )`; 插入操作12345678910// insert value 插入$sql = &quot;insert into table_test values(1, &apos;name1&apos;, 1)&quot;;// 插入部分字段$sql = &quot;insert into table_test (name,sex) values(&apos;name2&apos;, 2)&quot;;// 插入多条语句$sql = &quot;insert into table_test (name,sex) values(&apos;name1&apos;, 1), (&apos;name2&apos;, 2)&quot;;// insert set 插入$sql = &quot;insert into table_test set name=&apos;name1&apos;,sex=1&quot;;// insert select插入$sql = &quot;insert into table_test (name,sex) select name,sex from table_test where id=1&quot;; 修改操作12// update set修改$sql = &quot;update table_test set name=&apos;name2&apos; where id=1&quot;; 删除操作1234// delete where删除$sql = &quot;delete from table_test where id=1&quot;;// truncate table删除表所有行数据,且auto_increment 重新计数$sql = &quot;truncate table table_test&quot;; 查询操作 条件顺序如下： group by … having … order by … limit … 12345678// 普通查询$sql = &quot;select * from table_test&quot;;// in 查询$sql = &quot;select * from table_test where name in (&apos;name1&apos;, &apos;name2&apos;)&quot;;// distinct 查询某个字段去重(多字段表示多字段合并的去重 distinct name,sex)$sql = &quot;select distinct name from table_test&quot;;// group_concat(field1) group by field2(按field2分组后，field1的值用，隔开)$sql = &quot;select group_concat(money),order_id from table_test group by order_id&quot;; 聚合查询 count(*) 查询结果总数集sum(field) 计算字段求和总值avg(field) 计算字段平均值max(field) 计算字段最大值min(field) 计算字段最小值]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL之操作数据表]]></title>
    <url>%2F2018%2F07%2F07%2Fmysql_operation%2F</url>
    <content type="text"><![CDATA[文中均使用 table_test 作为表名 创建数据表12345create table if not exists table_test( id int(11) auto_increment primary key, name varchar(30) not null comment &apos;名称&apos;, password varchar(30) not null comment &apos;密码&apos;) comment=&quot;表名&quot;; 查看表结构12345show columns from table_test;或者describe table_test;或者desc table_test; 修改表结构1. 添加新字段及修改存在字段123alter table table_test add sex enum(&apos;male&apos;, &apos;female&apos;) not null default &apos;male&apos; comment &apos;性别&apos;, modify name varchar(40); 2. 修改表字段名12alter table table_test change column date create_time date null default &apos;0000-00-00&apos;; 3. 删除字段12alter table table_test drop create_time; 4. 修改表名12alter table table_test rename as table_test_new; 重命名表1rename table table_test_new to table_test; 复制表1. 复制表结构1create table table_test_copy1 like table_test; 2. 复制表结构及数据1create table table_test_copy2 as select * from table_test; 3. 复制部分表结构及数据 只复制了id,name两个字段的表结构1create table table_test_copy3 as select id,name from table_test&apos; 删除表1drop table if not exists table_test;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式之行为型模式（behavioral patterns）]]></title>
    <url>%2F2018%2F07%2F01%2Fbehavioral_patterns%2F</url>
    <content type="text"><![CDATA[责任链模式 为请求创建了一个接收者对象的链这种模式给予请求的类型，对请求的发送者和接收者进行解耦优点： 降低耦合度。它将请求的发送者和接收者解耦。 简化了对象。使得对象不需要知道链的结构。 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 增加新的请求处理类很方便。 缺点： 不能保证请求一定被接收。 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 可能不容易观察运行时的特征，有碍于除错 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php/** * 责任链模式 -- responsibility pattern */abstract class Responsibility&#123; protected $next; public function setNext(Responsibility $obj) &#123; $this-&gt;next = $obj; return $this; &#125; abstract public function operator();&#125;class ResponsibilityA extends Responsibility&#123; public function operator() &#123; if(false == is_null($this-&gt;next))&#123; $this-&gt;next-&gt;operator(); echo &quot;this is responsibility A&quot;; &#125; &#125;&#125;class ResponsibilityB extends Responsibility&#123; public function operator() &#123; if(false == is_null($this-&gt;next))&#123; $this-&gt;next-&gt;operator(); echo &quot;this is responsibility B&quot;; &#125; &#125;&#125;$responsibilityA = new ResponsibilityA();$responsibilityB = new ResponsibilityB();$responsibilityA-&gt;setNext($responsibilityB);$responsibilityA-&gt;operator(); 命令模式 请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。优点： 降低了系统耦合度。 新的命令可以很容易添加到系统中去。 缺点：使用命令模式可能会导致某些系统有过多的具体命令类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php/** * 命令模式 -- commandpattern */// 定义接口interface Command&#123; public function execute();&#125;class RealCommand implements Command&#123; private $_receiver; public function __construct(Receiver $receiver) &#123; $this-&gt;_receiver = $receiver; &#125; public function execute() &#123; $this-&gt;_receiver-&gt;action(); &#125;&#125;// 接受者class Receiver&#123; private $_name; public function __construct($name) &#123; $this-&gt;_name = $name; &#125; public function action() &#123; echo &quot;this is receiver&quot; . $this-&gt;_name; &#125;&#125;// 请求者class Invoker&#123; private $_realCommand; public function __construct(RealCommand $realCommand) &#123; $this-&gt;_realCommand = $realCommand; &#125; public function operator() &#123; $this-&gt;_realCommand-&gt;execute(); &#125;&#125;$receiver = new Receiver(&apos;hello world&apos;);$realCommand = new RealCommand($receiver);$invoker = new Invoker($realCommand);$invoker-&gt;operator(); 解释器模式 一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。优点： 可扩展性比较好，灵活。 增加了新的解释表达式的方式。 易于实现简单文法。 缺点： 可利用场景比较少。 对于复杂的文法比较难维护。 解释器模式会引起类膨胀。 解释器模式采用递归调用方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php/** * 解释器模式 -- interpreter pattern */interface Expression&#123; public function interpreter($data);&#125;class NumberExpression implements Expression&#123; public function interpreter($num) &#123; switch($num)&#123; case &apos;0&apos;: return &apos;零&apos;; case &apos;1&apos;: return &apos;一&apos;; case &apos;2&apos;: return &apos;二&apos;; case &apos;3&apos;: return &apos;三&apos;; case &apos;4&apos;: return &apos;四&apos;; case &apos;5&apos;: return &apos;五&apos;; case &apos;6&apos;: return &apos;六&apos;; case &apos;7&apos;: return &apos;七&apos;; case &apos;8&apos;: return &apos;八&apos;; case &apos;9&apos;: return &apos;久&apos;; default: return &apos;无&apos;; &#125; &#125;&#125;class StringExpression implements Expression&#123; public function interpreter($str) &#123; return strtoupper($str); &#125;&#125;class Interpreter&#123; public function execute($string) &#123; $expression = null; for($i=0; $i&lt;strlen($string); $i++)&#123; if(is_numeric($string[$i]))&#123; $expression = new NumberExpression(); &#125;elseif(is_string($string[$i]))&#123; $expression = new StringExpression(); &#125; echo $expression-&gt;interpreter($string[$i]); echo &quot;&lt;br/&gt;&quot;; &#125; &#125;&#125;$obj = new Interpreter();$obj-&gt;execute(&apos;123sqwe09843&apos;); 迭代器模式 顺序访问集合对象的元素，不需要知道集合对象的底层表示。优点： 它支持以不同的方式遍历一个聚合对象。 迭代器简化了聚合类。 在同一个聚合上可以有多个遍历。 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/** * 迭代器模式 -- iterator pattern */class Sample implements Iterator&#123; private $_item; public function __construct($data) &#123; $this-&gt;_item = $data; &#125; public function current() &#123; return current($this-&gt;_item); &#125; public function next() &#123; return next($this-&gt;_item); &#125; public function key() &#123; return key($this-&gt;_item); &#125; public function rewind() &#123; reset($this-&gt;_item); &#125; public function valid() &#123; return ($this-&gt;current() !== false); &#125;&#125;$data = array(&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;);$obj = new Sample($data);echo $obj-&gt;current();echo $obj-&gt;next();echo $obj-&gt;key();echo $obj-&gt;rewind();echo $obj-&gt;valid(); 中介者模式 降低多个对象和类之间的通信复杂性。该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。优点： 降低了类的复杂度，将一对多转化成了一对一。 各个类之间的解耦。 3、符合迪米特原则。 缺点：中介者会庞大，变得复杂难以维护。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php/** * 中介者模式 -- mediator pattern */abstract class Mediator&#123; abstract public function send($message, $colleague);&#125;abstract class Colleague&#123; private $_mediator; public function __construct($mediator) &#123; $this-&gt;_mediator = $mediator; &#125; public function send($message) &#123; $this-&gt;_mediator-&gt;send($message, $this); &#125; abstract public function notify($message);&#125;class Colleague1 extends Colleague&#123; public function notify($message) &#123; echo &quot;colleague1 &quot; . $message; &#125;&#125;class Colleague2 extends Colleague&#123; public function notify($message) &#123; echo &quot;colleague2 &quot; . $message; &#125;&#125;class NewMediator extends Mediator&#123; private $_colleauge1; private $_colleauge2; public function set($col1, $col2) &#123; $this-&gt;_colleauge1 = $col1; $this-&gt;_colleauge2 = $col2; &#125; public function send($message, $colleague) &#123; if($this-&gt;_colleauge1 == $colleague)&#123; $this-&gt;_colleauge1-&gt;notify($message); &#125;else&#123; $this-&gt;_colleauge2-&gt;notify($message); &#125; &#125;&#125;$newMediator = new NewMediator();$col1 = new Colleague1($newMediator);$col2 = new Colleague2($newMediator);$newMediator-&gt;set($col1, $col2);$col1-&gt;send(&apos;hello col1&apos;);$col2-&gt;send(&apos;hello col2&apos;); 备忘录模式 保存一个对象的某个状态，以便在适当的时候恢复对象所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态通过一个备忘录类专门存储对象状态客户不与备忘录类耦合，与备忘录管理类耦合优点： 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 注意事项： 为了符合迪米特原则，还要增加一个管理备忘录的类。 为了节约内存，可使用原型模式+备忘录模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?php/** * 备忘录模式 -- memento pattern */class Memento&#123; private $_memento; public function __construct(string $state) &#123; $this-&gt;_memento = $state; &#125; public function getState() &#123; return $this-&gt;_memento; &#125;&#125;class Originator&#123; private $_state; public function setState(string $state) &#123; $this-&gt;_state = $state; &#125; public function getState() &#123; return $this-&gt;_state; &#125; public function saveMemento() &#123; return new Memento($this-&gt;_state); &#125; public function getMemento(Memento $memento) &#123; $this-&gt;_state = $memento-&gt;getState(); &#125;&#125;class CakeTask&#123; private $_mementoList; public function __construct() &#123; $this-&gt;_mementoList = array(); &#125; public function add(Memento $memento) &#123; $this-&gt;_mementoList[] = $memento; &#125; public function get(int $index) &#123; return $this-&gt;_mementoList[$index]; &#125;&#125;$originator = new Originator();$cakeTask = new CakeTask();$originator-&gt;setState(&apos;hello one&apos;);$originator-&gt;setState(&apos;hello two&apos;);$cakeTask-&gt;add($originator-&gt;saveMemento());$originator-&gt;setState(&apos;hello three&apos;);$cakeTask-&gt;add($originator-&gt;saveMemento());$originator-&gt;setState(&apos;hello four&apos;);echo $originator-&gt;getState();$originator-&gt;getMemento($cakeTask-&gt;get(0));echo $originator-&gt;getState();$originator-&gt;getMemento($cakeTask-&gt;get(1));echo $originator-&gt;getState(); 观察者模式 对象间存在一对多关系当一个对象被修改时，则会自动通知它的依赖对象并被自动更新优点： 观察者和被观察者是抽象耦合的。 建立一套触发机制。 缺点： 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 注意事项： 避免循环引用。 如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** * 观察者模式 -- observer pattern */// 定义接口interface Observer&#123; public function onSendMsg($name); public function getName();&#125;class UserListLogger implements Observer&#123; public function onSendMsg($name) &#123; echo $name . &apos; send to UserListLogger&apos;; &#125; public function getName() &#123; return &apos;userlist_logger&apos;; &#125;&#125;class OtherObserver implements Observer&#123; public function onSendMsg($name) &#123; echo $name . &apos; send to OtherObserver&apos;; &#125; public function getName() &#123; return &apos;other_observer&apos;; &#125;&#125;interface Observerable&#123; public function add(Observer $observer); public function remove($name);&#125;class UserList implements Observerable&#123; private $_observer = array(); public function add(Observer $observer) &#123; $this-&gt;_observer[] = $observer; &#125; public function remove($name) &#123; foreach($this-&gt;_observer as $k=&gt;$val)&#123; if($val-&gt;getName() == $name)&#123; unset($this-&gt;_observer[$k]); &#125; &#125; &#125; public function sendMsg($name) &#123; foreach($this-&gt;_observer as $val)&#123; $val-&gt;onSendMsg($name); &#125; &#125;&#125;$userList = new UserList();$userList-&gt;add(new UserListLogger());$userList-&gt;add(new OtherObserver());$userList-&gt;sendMsg(&apos;jone&apos;);$userList-&gt;remove(&apos;userlist_logger&apos;);$userList-&gt;sendMsg(&apos;jami&apos;); 状态模式 类的行为是基于它的状态改变的对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。优点： 封装了转换规则。 枚举可能的状态，在枚举状态之前需要确定状态种类。 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点： 状态模式的使用必然会增加系统类和对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?php/** * 状态模式 -- state pattern */interface State&#123; public function handle(Context $context);&#125;class StateA implements State&#123; private static $_instance; private function __construct() &#123; &#125; public static function getInstance() &#123; if(is_null(self::$_instance))&#123; self::$_instance = new StateA(); &#125; return self::$_instance; &#125; public function handle(Context $context) &#123; echo &quot;context A&quot;; $context-&gt;setState(StateB::getInstance()); &#125;&#125;class StateB implements State&#123; private static $_instance; private function __construct() &#123; &#125; public static function getInstance() &#123; if(is_null(self::$_instance))&#123; self::$_instance = new StateB(); &#125; return self::$_instance; &#125; public function handle(Context $context) &#123; echo &quot;context B&quot;; $context-&gt;setState(StateA::getInstance()); &#125;&#125;class Context&#123; private $_state; public function __construct() &#123; $this-&gt;_state = StateA::getInstance(); &#125; public function setState(State $state) &#123; $this-&gt;_state = $state; &#125; public function request() &#123; $this-&gt;_state-&gt;handle($this); &#125;&#125;$context = new Context();$context-&gt;request();$context-&gt;request();$context-&gt;request();$context-&gt;request(); 空对象模式 一个空对象取代 NULL 对象实例的检查在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php/** * 空对象模式 -- null object pattern */abstract class AbstractCustom&#123; private $_name; abstract public function isNil(); abstract public function getName();&#125;class RealCustom extends AbstractCustom&#123; private $_name; public function __construct($name) &#123; $this-&gt;_name = $name; &#125; public function getName() &#123; return $this-&gt;_name; &#125; public function isNil() &#123; return false; &#125;&#125;class NullCustom extends AbstractCustom&#123; public function getName() &#123; return &quot;this is null custom&quot;; &#125; public function isNil() &#123; return false; &#125;&#125;class NullFactory&#123; private $_arr = array(&apos;one&apos;, &apos;two&apos;); public function getCustom($name)&#123; if(in_array($name, $this-&gt;_arr))&#123; return new RealCustom($name); &#125; return new NullCustom(); &#125;&#125;$obj = new NullFactory();$test1 = $obj-&gt;getCustom(&apos;one&apos;);$test2 = $obj-&gt;getCustom(&apos;one_one&apos;);$test3 = $obj-&gt;getCustom(&apos;two&apos;);$test4 = $obj-&gt;getCustom(&apos;two_two&apos;);echo $test1-&gt;getName();echo $test2-&gt;getName();echo $test3-&gt;getName();echo $test4-&gt;getName(); 策略模式 一个类的行为或其算法可以在运行时更改定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换优点： 算法可以自由切换。 避免使用多重条件判断。 扩展性良好。 缺点： 策略类会增多。 所有策略类都需要对外暴露。 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php/** * 策略模式 -- strategy pattern */interface Strategy&#123; public function do_method();&#125;class StrategyA implements Strategy&#123; public function do_method() &#123; echo &quot;this is strategy A&quot;; &#125;&#125;class StrategyB implements Strategy&#123; public function do_method() &#123; echo &quot;this is strategy B&quot;; &#125;&#125;class StrategyC implements Strategy&#123; public function do_method() &#123; echo &quot;this is strategy C&quot;; &#125;&#125;class Question&#123; private $_strategy; public function __construct($strategy) &#123; $this-&gt;_strategy = $strategy; &#125; public function handle() &#123; $this-&gt;_strategy-&gt;do_method(); &#125;&#125;$a = new Question(new StrategyA());$a-&gt;handle();$b = new Question(new StrategyB());$b-&gt;handle();$c = new Question(new StrategyC());$c-&gt;handle(); 模板模式 一些方法通用，却在每一个子类都重新写了这一方法将这些通用算法抽象出来在抽象类实现，其他步骤在子类实现优点： 封装不变部分，扩展可变部分。 提取公共代码，便于维护。 行为由父类控制，子类实现。 缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。 123456789101112131415161718192021222324252627&lt;?php/** * 模板模式 -- template pattern */abstract class Game&#123; abstract public function start(); abstract public function end(); public function action() &#123; $this-&gt;start(); $this-&gt;end(); &#125;&#125;class SuperMary extends Game&#123; public function start() &#123; echo &quot;the game is starting&quot;; &#125; public function end() &#123; echo &quot;the game is ending&quot;; &#125;&#125;$superMary = new SuperMary();$superMary-&gt;action(); 访问者模式 使用了一个访问者类，它改变了元素类的执行算法元素的执行算法可以随着访问者改变而改变稳定的数据结构和易变的操作耦合问题。在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。优点： 符合单一职责原则。 优秀的扩展性。 灵活性。 缺点： 具体元素对访问者公布细节，违反了迪米特原则。 具体元素变更比较困难。 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。 注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php/** * */interface ComputerPart&#123; public function accept(Visitor $visitor);&#125;class Computer implements ComputerPart&#123; private $_computerPart = array(); public function accept(Visitor $visitor) &#123; foreach($this-&gt;_computerPart as $val)&#123; $val-&gt;accept($visitor); &#125; $visitor-&gt;visit($this); &#125; public function getName() &#123; return &apos;computer&apos;; &#125; public function setAttach(ComputerPart $computerPart) &#123; array_push($this-&gt;_computerPart, $computerPart); &#125;&#125;class Mouse implements ComputerPart&#123; public function accept(Visitor $visitor) &#123; $visitor-&gt;visit($this); &#125; public function getName() &#123; return &apos;mouse&apos;; &#125;&#125;class KeyBoard implements ComputerPart&#123; public function accept(Visitor $visitor) &#123; $visitor-&gt;visit($this); &#125; public function getName() &#123; return &apos;keyboard&apos;; &#125;&#125;class Visitor&#123; public function visit(ComputerPart $computerPart) &#123; echo &quot;this is &quot;.$computerPart-&gt;getName(); &#125;&#125;$computer = new Computer();$computer-&gt;setAttach(new Mouse());$computer-&gt;setAttach(new KeyBoard());$computer-&gt;accept(new Visitor());]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式之结构型模式（structural patterns）]]></title>
    <url>%2F2018%2F06%2F17%2Fstructrual_patterns%2F</url>
    <content type="text"><![CDATA[适配器模式 涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。适配器继承或依赖已有的对象，实现想要的目标接口。优点： 可以让任何两个没有关联的类一起运行。 提高了类的复用。 增加了类的透明度。 灵活性好。 缺点： 过多使用适配器会让系统凌乱，不易整体把握，没有必要，不建议使用适配器模式 注意事项：适配器不是在详细设计时使用的，而是在解决正在服役的项目使用的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** * adapter pattern 适配器模式 */// 对象适配器// 定义接口interface target&#123; public function echoSample1(); public function echoSample2();&#125;class adapterOne implements target&#123; public function echoSample1() &#123; echo &quot;+++++&quot;; &#125; public function echoSample2() &#123; &#125;&#125;class adapterTwo implements target&#123; private $adapterOne; public function __construct(adapterOne $obj) &#123; $this-&gt;adapterOne = $obj; &#125; public function echoSample1() &#123; $this-&gt;adapterOne-&gt;echoSample1(); &#125; public function echoSample2() &#123; echo &apos;----&apos;; &#125;&#125;$adapterTwo = new adapterTwo(new adapterOne);$adapterTwo-&gt;echoSample1();$adapterTwo-&gt;echoSample2();// 类适配器interface target2&#123; public function echoSample1(); public function echoSample2();&#125;class adapterClassOne&#123; public function echoSample1() &#123; echo &quot;****&quot;; &#125;&#125;class adapterClassTwo extends adapterClassOne implements target2&#123; public function echoSample2() &#123; echo &quot;&amp;&amp;&amp;&amp;&quot;; &#125;&#125;$adapterClassTwo = new adapterClassTwo();$adapterClassTwo-&gt;echoSample1();$adapterClassTwo-&gt;echoSample2(); 桥接模式 把抽象化与实现化解耦，使得二者可以独立变化抽象类依赖实现类。优点： 抽象和实现的分离。 优秀的扩展能力。 实现细节对客户透明。 缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php/** * 桥接模式 -- bridge pattern */// 定义接口--对象interface DrawApi&#123; public function draw();&#125;class RedColor implements DrawApi&#123; public function draw() &#123; echo &quot;red color&quot;; &#125;&#125;class GreenColor implements DrawApi&#123; public function draw() &#123; echo &quot;green color&quot;; &#125;&#125;// 定义抽象类abstract class Shape&#123; abstract public function draw();&#125;class Circle extends Shape&#123; private $drawApi; public function __construct(DrawApi $obj) &#123; $this-&gt;drawApi = $obj; &#125; public function draw() &#123; $this-&gt;drawApi-&gt;draw(); &#125;&#125;$obj = new Circle(new RedColor());$obj-&gt;draw();$obj2 = new Circle(new GreenColor());$obj2-&gt;draw(); 过滤器模式 使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?php/** * 过滤器模式 -- filter pattern */// 定义接口interface Shape&#123; public function arrayPrint(array $arr);&#125;class One implements Shape&#123; public function arrayPrint(array $arr) &#123; $array = array(); foreach($arr as $v)&#123; if($v-&gt;getName() == &apos;one&apos;)&#123; $array[] = $v; &#125; &#125; return $array; &#125;&#125;class Two implements Shape&#123; public function arrayPrint(array $arr) &#123; $array = array(); foreach($arr as $v)&#123; if($v-&gt;getName() == &apos;two&apos;)&#123; $array[] = $v; &#125; &#125; return $array; &#125;&#125;class Three implements Shape&#123; public function arrayPrint(array $arr) &#123; $array = array(); foreach($arr as $v)&#123; if($v-&gt;getID() == &apos;2&apos;)&#123; $array[] = $v; &#125; &#125; return $array; &#125;&#125;// 定义标准类class Data&#123; private $id; private $name; public function __construct($id, $name) &#123; $this-&gt;id = $id; $this-&gt;name = $name; &#125; public function getID() &#123; return $this-&gt;id; &#125; public function getName() &#123; return $this-&gt;name; &#125;&#125;$array = array();$array[] = new Data(&apos;1&apos;, &apos;one&apos;);$array[] = new Data(&apos;2&apos;, &apos;one&apos;);$array[] = new Data(&apos;3&apos;, &apos;two&apos;);$array[] = new Data(&apos;4&apos;, &apos;three&apos;);$one = new One();arrayPrint($one-&gt;arrayPrint($array));$two = new Two();arrayPrint($two-&gt;arrayPrint($array));$three = new Three();arrayPrint($three-&gt;arrayPrint($one-&gt;arrayPrint($array)));function arrayPrint($arr)&#123; foreach($arr as $v)&#123; echo $v-&gt;getID(); echo $v-&gt;getName(); &#125;&#125; 组合模式 一组相似的对象当作一个单一的对象组合模式依据树形结构来组合对象，用来表示部分以及整体层次意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。优点： 高层模块调用简单。 节点自由增加。 缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。注意事项：定义时为具体类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php/** * 组合模式 -- composite pattern */interface Shape&#123; public function add($obj); public function remove($obj); public function operator();&#125;class Composite implements Shape&#123; private $_composite; public function __construct() &#123; $this-&gt;_composite = array(); &#125; public function operator() &#123; foreach($this-&gt;_composite as $v)&#123; $v-&gt;operator(); &#125; &#125; public function add($obj) &#123; $this-&gt;_composite[] = $obj; &#125; public function remove($obj) &#123; foreach($this-&gt;_composite as $k=&gt;$v)&#123; if($obj == $v)&#123; unset($this-&gt;_composite[$k]); return true; &#125; &#125; return false; &#125;&#125;class Leaf implements Shape&#123; private $_name; public function __construct($name) &#123; $this-&gt;_name = $name; &#125; public function add($obj)&#123;&#125; public function remove($obj)&#123;&#125; public function operator() &#123; echo $this-&gt;_name; &#125;&#125;$leaf1 = new Leaf(&apos;one&apos;);$leaf2 = new Leaf(&apos;two&apos;);$composite = new Composite();$composite-&gt;add($leaf1);$composite-&gt;add($leaf2);$composite-&gt;operator();$composite-&gt;remove($leaf1);$composite-&gt;operator(); 装饰器模式 允许向一个现有的对象添加新的功能，同时又不改变其结构优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。缺点：多层装饰比较复杂。注意事项：可代替继承。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php/** * 装饰器模式 -- decorator pattern */// 定义接口interface Shape&#123; public function draw();&#125;class Decorator implements Shape&#123; private $_decorator; public function __construct(Shape $decorator) &#123; $this-&gt;_decorator = $decorator; &#125; public function draw() &#123; $this-&gt;_decorator-&gt;draw(); &#125;&#125;class RedColor extends Decorator&#123; public function __construct(Shape $decorator) &#123; parent::__construct($decorator); &#125; public function draw() &#123; parent::draw(); $this-&gt;echoDraw(); &#125; public function echoDraw() &#123; echo &quot;red color&quot;; &#125;&#125;class GreenColor extends Decorator&#123; public function __construct(Shape $decorator) &#123; parent::__construct($decorator); &#125; public function draw() &#123; parent::draw(); $this-&gt;echoDraw(); &#125; public function echoDraw() &#123; echo &quot;green color&quot;; &#125;&#125;class Color implements Shape&#123; public function draw()&#123; echo &quot;color&quot;; &#125;&#125;$obj = new Color();$obj_red = new RedColor($obj);$obj_green = new GreenColor($obj_red);$obj_red-&gt;draw();$obj_green-&gt;draw(); 外观模式 隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。优点： 减少系统相互依赖。 提高灵活性。 提高了安全性。 缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php/** * 门面模式/外观模式 -- facade pattern *///定义接口interface Shape&#123; public function draw();&#125;class Red implements Shape&#123; public function draw() &#123; echo &quot;red&quot;; &#125;&#125;class Green implements Shape&#123; public function draw() &#123; echo &quot;green&quot;; &#125;&#125;class Demo&#123; private $_red; private $_green; public function __construct() &#123; $this-&gt;_red = new Red(); $this-&gt;_green = new Green(); &#125; public function draw() &#123; $this-&gt;_red-&gt;draw(); $this-&gt;_green-&gt;draw(); &#125;&#125;$obj = new Demo();$obj-&gt;draw(); 享元模式 减少创建对象的数量，以减少内存占用和提高性能用 HashMap 存储这些对象。优点：大大减少对象的创建，降低系统的内存，使效率提高。缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。注意事项： 注意划分外部状态和内部状态，否则可能会引起线程安全问题。 这些类必须有一个工厂对象加以控制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php/** * 享元模式 -- flyweight pattern */abstract class Resource&#123; private $_resource = null; abstract public function operator();&#125;class UnShare extends Resource&#123; public function __construct($str) &#123; $this-&gt;_resource = $str; &#125; public function operator() &#123; echo $this-&gt;_resource; &#125;&#125;class Share extends Resource&#123; private $_resources = array(); public function setResource($str) &#123; if(isset($this-&gt;_resources[$str]))&#123; return $this-&gt;_resources[$str]; &#125;else&#123; return $this-&gt;_resources[$str] = $str; &#125; &#125; public function operator() &#123; foreach($this-&gt;_resources as $key=&gt;$val)&#123; echo $key . &apos;=&gt;&apos; . $val; &#125; &#125;&#125;$obj = new Share();$obj-&gt;setResource(&apos;a&apos;);$obj-&gt;operator();$obj-&gt;setResource(&apos;b&apos;);$obj-&gt;operator();$objUnShare = new UnShare(&apos;A&apos;);$objUnShare-&gt;operator();$objUnShare = new UnShare(&apos;B&apos;);$objUnShare-&gt;operator(); 代理模式 为其他对象提供一种代理以控制对这个对象的访问。实现与被代理类组合。优点： 职责清晰。 高扩展性。 智能化。 缺点： 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 注意事项： 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php/** * 代理模式 -- proxy pattern */abstract class Subject&#123; abstract public function draw();&#125;class RealSubject extends Subject&#123; public function draw() &#123; echo &quot;real subject&quot;; &#125;&#125;class ProxySubject extends Subject&#123; private $_subject = null; public function draw() &#123; $this-&gt;before(); if(is_null($this-&gt;_subject))&#123; $this-&gt;_subject = new RealSubject(); &#125; $this-&gt;_subject-&gt;draw(); $this-&gt;after(); &#125; public function before() &#123; echo &quot;before&quot;; &#125; public function after() &#123; echo &quot;after&quot;; &#125;&#125;$obj = new ProxySubject();$obj-&gt;draw();]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式之创建型模式（creational patterns）]]></title>
    <url>%2F2018%2F06%2F16%2Fcreational_patterns%2F</url>
    <content type="text"><![CDATA[工厂模式 定义一个创建对象的接口，让其子类决定去实例化哪一个工厂类创建的过程是在子类中执行优点： 调用者想创建一个对象只需要知道名称即可 扩展性高，想增加一个产品，只需要扩展一个工厂类就可以 屏蔽产品具体实现，调用者只关心产品的接口 缺点： 每增加一个产品，都需要增加一个具体类和对象实现工厂，使得系统类的个数成倍增加，一定程度上增加了系统复杂度，同时也增加了系统具体类的依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*** ------------工厂模式 factory----------------------- ***/class DB&#123; public function __construct() &#123; echo get_class(); &#125; public function die() &#123; &#125;&#125;class Mysql extends DB&#123;&#125;class SqlSrv extends DB&#123;&#125;class Odbc extends DB&#123;&#125;interface TestFactory&#123; public function toString();&#125;class Factory implements TestFactory&#123; public function toString()&#123; &#125; public function do($type) &#123; switch($type)&#123; case &apos;Mysql&apos;: return new Mysql(); case &apos;SqlSrv&apos;: return new SqlSrv(); case &apos;Odbc&apos;: return new Odbc(); &#125; &#125;&#125;$test = new Factory();$test-&gt;do(&apos;Mysql&apos;);$test-&gt;do(&apos;SqlSrv&apos;);$test-&gt;do(&apos;Odbc&apos;); 抽象工厂模式 围绕一个超级工厂创建其他工厂，该超级工厂是其他工厂的工厂一个工厂中聚合多个同类产品优点： 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。缺点： 产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。注意事项： 产品族难扩展，产品等级易扩展。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*** ------------抽象工厂模式 abstract factory----------------------- ***/class Cache&#123;&#125;class CacheDie&#123;&#125;class FileCache extends Cache&#123; public function __construct() &#123; echo &quot;filecache&quot;; &#125;&#125;class RedisCache extends Cache&#123; public function __construct() &#123; echo &quot;rediscache&quot;; &#125;&#125;class FileCacheDie extends CacheDie&#123; public function __construct() &#123; echo &quot;FileCacheDie&quot;; &#125;&#125;class RedisCacheDie extends CacheDie&#123; public function __construct() &#123; echo &quot;RedisCacheDie&quot;; &#125;&#125;class CacheAbstractFactory&#123; public function createCache($type)&#123; switch ($type) &#123; case &apos;file&apos;: return new FileCache(); case &apos;redis&apos;: return new RedisCache(); default: break; &#125; &#125;&#125;class CacheDieAbstractFactory&#123; public function createCache($type)&#123; switch ($type) &#123; case &apos;file&apos;: return new FileCacheDie(); case &apos;redis&apos;: return new RedisCacheDie(); default: break; &#125; &#125;&#125;class TestAbstractFactory&#123; public function createType($type) &#123; switch ($type) &#123; case &apos;cache&apos;: return new CacheAbstractFactory(); case &apos;cacheDie&apos;: return new CacheDieAbstractFactory(); default: break; &#125; &#125;&#125;$testAbstractFactory = new TestAbstractFactory();$cache = $testAbstractFactory-&gt;createType(&apos;cache&apos;);$cache-&gt;createCache(&apos;file&apos;);$cache-&gt;createCache(&apos;redis&apos;);$cacheDie = $testAbstractFactory-&gt;createType(&apos;cacheDie&apos;);$cacheDie-&gt;createCache(&apos;file&apos;);$cacheDie-&gt;createCache(&apos;redis&apos;);/*** ----------------------------------- ***/ 单例模式 负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。注意： 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 优点： 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例 避免对资源的多重占用（比如写文件操作）。 缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。注意事项： getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 12345678910111213141516171819202122232425262728293031&lt;?php/*** -----------单例模式 singleton------------ ***/final class TestSingle&#123; private static $instance; public static function getInstance() &#123; if(!(self::$instance instanceof self ))&#123; self::$instance = new self(); &#125; return self::$instance; &#125; private function __construct() &#123; &#125; public function toString() &#123; echo &quot;string&quot;; &#125;&#125;$test = TestSingle::getInstance();$test-&gt;toString();/*** ----------------------------------- ***/ 建造者模式 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。优点： 建造者独立，易扩展。 便于控制细节风险。 缺点： 产品必须有共同点，范围有限制。 如内部变化复杂，会有很多的建造类。 注意事项： 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*** --------------建造者模式 builder--------------------- ***/class Product&#123; private $_arr; public function __construct() &#123; $this-&gt;_arr = array(); &#125; public function add($part) &#123; return array_push($this-&gt;_arr, $part); &#125;&#125;class Builder&#123; private $_product; public function __construct() &#123; $this-&gt;_product = new Product(); &#125; public function add1($part) &#123; $this-&gt;_product-&gt;add($part); &#125; public function add2($part) &#123; $this-&gt;_product-&gt;add($part); &#125; public function getPart() &#123; return $this-&gt;_product; &#125;&#125;class Director&#123; public function __construct(Builder $builder) &#123; $builder-&gt;add1(&apos;arr1&apos;); $builder-&gt;add2(&apos;add2&apos;); &#125;&#125;$test_builder = new Builder();$test_director = new Director($test_builder);print_r($test_builder-&gt;getPart());/*** ----------------------------------- ***/ 原型模式 实现了一个原型接口，该接口用于创建当前对象的克隆。实现克隆 clone优点： 性能提高。 逃避构造函数的约束。 缺点： 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 必须实现 Cloneable 接口。 注意事项： 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。 123456789101112131415161718192021/*** --------------原型模式 prototype--------------------- ***/class ProtoType&#123; private $_name; public function __construct($obj) &#123; $this-&gt;_name = $obj; &#125; public function copy() &#123; return clone $this; &#125;&#125;class TestProto&#123;&#125;$testProto = new ProtoType(new TestProto());print_r($testProto);$testProtoCopy = $testProto-&gt;copy();print_r($testProtoCopy);/*** ----------------------------------- ***/]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式（design patterns of PHP）]]></title>
    <url>%2F2018%2F06%2F16%2Fdesign_patterns%2F</url>
    <content type="text"><![CDATA[23种设计模式 以下包含java设计模式的思想（共25种设计模式）三大类：创建型模式（creational patterns）、结构型模式（structural patterns）、行为型模式（behavioral patterns） 创建型模式（creational patterns）:： 工厂模式 – factory pattern 抽象工厂模式 – abstract factory pattern 单例模式 – singleton pattern 建造者模式 – builder pattern 原型模式 – prototype pattern 结构型模式（structural patterns）: 适配器模式 – adapter pattern 桥接模式 – bridge pattern 过滤器模式/标准模式 – filter pattern / criteria pattern 组合模式 – composite pattern 装饰器模式 – decorator pattern 外观模/门面模式 – facade pattern 享元模式 – flyweight pattern 代理模式 – proxy pattern 行为型模式（behavioral patterns）： 责任链模式 – responsibility pattern 命令模式 – command pattern 解释器模式 – expression pattern 迭代器模式 – iterator pattern 中介者模式 – mediator pattern 备忘录模式 – memento pattern 观察者模式 – observer pattern 状态模式 – state pattern 空对象模式 – null object pattern 策略模式 – strategy pattern 模板模式 – template pattern 访问者模式 – visitor pattern]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下关于服务端口的配置]]></title>
    <url>%2F2018%2F06%2F10%2Fserver_port%2F</url>
    <content type="text"><![CDATA[端口服务 查看端口使用情况 123456789netstat命令各个参数说明如下: -t : 指明显示TCP端口 -u : 指明显示UDP端口 -l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序) -p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。 -n : 不进行DNS轮询，显示IP(可以加速操作)netstat -ntlp //查看当前所有tcp端口·netstat -ntulp |grep 80 //查看所有80端口使用情况·netstat -an | grep 3306 //查看所有3306端口使用情况· 端口映射配置 需求：PC_A是 eth0: 172.18.10.212 内网；eth1: 219.239.xx.xx 外网 PC_B是 172.18.10.205 内网 A的8080端口映射到B的80端口 1. 首先应该做的是123/etc/sysctl.conf配置文件: net.ipv4.ip_forward = 1 默认是0.这样允许iptalbes FORWARD。 2. 在/etc/rc.d/init.d目录下有iptables 文件，使用格式如下12345678910Usage: ./iptables &#123;start|stop|restart|condrestart|status|panic|save&#125; 相当与service iptables &#123;....&#125; 把iptables 服务停止，清除以前的规则，存盘 到/etc/rc.d/init.d目录下，运行 ./iptables stop iptalbes -F iptalbes -X iptalbes -Z ./iptables save 3. 重新配置规则123456789iptables -t nat -A PREROUTING -d 219.239.xx.xx -p tcp --dport 8080 -j DNAT --to-destination 172.18.10.205:80iptables -t nat -A POSTROUTING -d 172.18.10.205 -p tcp --dport 80 -j SNAT --to 172.18.10.212iptables -A FORWARD -o eth0 -d 172.18.10.205 -p tcp --dport 80 -j ACCEPTiptables -A FORWARD -i eth0 -s 172.18.10.205 -p tcp --sport 80 -j ACCEPTDNAT SNAT 的请参考帮助，这里不再陈述。 4. 新的规则存盘1234 ./iptables save规则存盘后在/etc/sysconfig/iptables这个文件里面，若你对这个文件很熟悉直接修改这里的内容也等于命令行方式输入规则。 5. 启动iptables 服务123456./iptables start在/proc/net/ip_conntrack文件里有包的流向，如下面 tcp 6 53 TIME_WAIT src=221.122.59.2 dst=219.239.xx.xx sport=7958 dport=8080 packets=9 bytes=1753 src=172.18.10.205 dst=172.18.10.212 sport=80 dport=7958 packets=9 bytes=5777 [ASSURED] use=1]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的三种bind/One/Live/On事件绑定使用方法]]></title>
    <url>%2F2018%2F05%2F20%2Fjs_5%2F</url>
    <content type="text"><![CDATA[on(events,[selector],[data],fn) events:一个或多个用空格分隔的事件类型和可选的命名空间，如”click”或”keydown.myPlugin” 。selector:一个选择器字符串用于过滤器的触发事件的选择器元素的后代。如果选择器为null或省略，当它到达选定的元素，事件总是触发。data:当一个事件被触发时要传递event.data给事件处理函数。fn:该事件被触发时执行的函数。 false 值也可以做一个函数的简写，返回false 替换bind() 当第二个参数’selector’为null时，on()和bind()其实在用法上基本上没有任何区别了，所以我们可以认为on()只是比bind()多了一个可选的’selector’参数，所以on()可以非常方便的换掉bind() 替换live() 在1.4之前相信大家非常喜欢使用live(),因为它可以把事件绑定到当前以及以后添加的元素上面，当然在1.4之后delegate()也可以做类似的事情了。live()的原理很简单，它是通过document进行事件委派的，因此我们也可以使用on()通过将事件绑定到document来达到live()一样的效果。 live()写法1234$(&apos;#list li&apos;).live(&apos;click&apos;, &apos;#list li&apos;, function() &#123; //function code here.&#125;); on()写法12345$(document).on(&apos;click&apos;, &apos;#list li&apos;, function() &#123; //function code here.&#125;); 这里的关键就是第二个参数’selector’在起作用了。它是一个过滤器的作用，只有被选中元素的后代元素才会触发事件。 替换delegate() delegate()是1.4引入的，目的是通过祖先元素来代理委派后代元素的事件绑定问题，某种程度上和live()优点相似。只不过live()是通过document元素委派，而delegate则可以是任意的祖先节点。使用on()实现代理的写法和delegate()基本一致。 delegate()的写法1234$(&apos;#list&apos;).delegate(&apos;li&apos;, &apos;click&apos;, function() &#123; //function code here.&#125;); on()写法1234$(&apos;#list&apos;).on(&apos;click&apos;, &apos;li&apos;, function() &#123; //function code here.&#125;); 貌似第一个和第二个参数的顺序颠倒了一下，别的基本一样。 总结 jQuery推出on()的目的有2个，一是为了统一接口，二是为了提高性能，所以从现在开始用on()替换bind(),live(),delegate吧。尤其是不要再用live()了，因为它已经处于不推荐使用列表了，随时会被干掉。如果只绑定一次事件，那接着用one()吧，这个没有变化。jQuery是 一款优秀的JavaScript框架,在旧版里主要用bind()方法，在新版里又多了两种One(),Live()下面介绍这几种方法的使用： 1. bind/Unbind 在jquery的事件模型中，有两个基本的事件绑 定函数，bind与unbind，这两个函数的含义就是匹配页面元素进行相关事件的处理。比如我们在JS中经常使用到的 onfocus，onblur，onmouseover，onmousedown等事件都可以作为bind的参数进行传递。$(“#id”).bind(‘click’,function(){alert(‘tt!’)});其中bind的第一个参数代表的含义是：事件类型(注意不需要加on)，function中的代码就是你要执行的逻辑 代码多个事件绑定：bind还允许你绑定多个事件，事件名字之间用空格隔开，例如：$(‘a’).bind(‘click mouseover’,function(){在最新的jquery1.4版本中，对bind方法进行了改进，你可以在bind方法传入一个类JSON对象来一次绑定多 个事件处理函数。12345678$(&apos;a&apos;).bind(&#123; click:function()&#123; alert(&apos;a&apos;); &#125;, mouseover:function()&#123; alert(&apos;a again!&apos;) &#125;&#125;) 在function函数中，你还可以通过传递一个javaScript对 象给function方法，这个事件对象通常是可以省略的。bind中还有一个参数data， 该参数一般情况下很少使用，通常为了解决在同一个方法中处理同一个变量时有很好的处理。12345678var productname=&quot;Sports Shoes&quot;; $(&apos;#Area&apos;).bind(&apos;click&apos;,function()&#123; alert(productname);&#125;);productname=&quot;necklace&quot;,$(&apos;#Area&apos;).bind(&apos;click&apos;,function()&#123; alert(productname);&#125;); 由于变量productname被重新赋值，所以输出的消息都是”necklace”,这里不了解可以去查阅下关于JavaScript的变量作用域,要 解决这个问题就必须使用到data参数，12345678var productname=&quot;Sports Shoes&quot;;$(&apos;#Area&apos;).bind(&apos;click&apos;,&#123;pn:productname&#125;,function()&#123; alert(event.data.pn);&#125;);productname=&quot;necklace&quot;,$(&apos;#Area&apos;).bind(&apos;click&apos;,&#123;pn:productname&#125;,function()&#123; alert(event.data.pn);&#125;); 2. One为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。该方法与bind方法的参数一样，与bind方法的区别就是只对匹配元素的事 件处理执行一次，执行完之后，以后再也不会执行,当然重新发起web请求时它又会执行一次。123$(&apos;a&apos;).one(&apos;click&apos;,function()&#123; alert(&apos;a&apos;);&#125;) 单击页面上的a元素后，弹出消息，除非用户发起第二次请求，否则再次点击a元素不会弹出消息对话框。 3. live该方法主要是能处理动态添加的元素，给那些后添加的元素也一样绑定事件。123$(&apos;a&apos;).live(&apos;click,function()&#123; alert(&apos;show message!&apos;);&#125;) 然后如果我添加一个元素，$(‘body’).appnend(‘Another Element’);那么该元素也会被触发事件处理函数alert。另外，jQuery还提供了一些绑定这些标准事件类型的简单方式，比如.click()用于简化.bind(‘click’)。一共有以下这些事件名称：blur, focus, focusin, focusout, load, resize, scroll, unload, click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout, mouseenter, mouseleave, change, select, submit, keydown, keypress, keyup, error 等。下面看下jQuery中绑定事件bind() on() live() one()的异同jQuery中绑定事件的四种方法，他们可以同时绑定一个或多个事件1234bind()----------版本号小于3.0（在Jquery3.0中已经移除，相应unbind()也移除）live()----------版本号小于1.7（在Jquery1.7中已经移除，相应die()也移除）delegate()------版本号小于1.7（在Jquery1.7中已经移除）on()------------版本号大于1.7（在Jquery1.7中添加，相应off()也添加） A：bind()事件的用法12345678910111213141516171819&lt;title&gt;绑定事件&lt;/title&gt; &lt;script src=&quot;js/jQuery1.11.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&quot;p&quot;).bind(&#123; &quot;mouseover&quot;: function () &#123; $(&quot;p&quot;).css(&quot;background-color&quot;, &quot;red&quot;); &#125;, &quot;mouseout&quot;: function () &#123; $(&quot;p&quot;).css(&quot;background-color&quot;, &quot;&quot;); &#125; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;what are you doing?&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 第一个最大的区别就是：bind()的事件绑定是只对当前页面选中的元素有效。如果你想对动态创建的元素bind()事件，是没有办法达到效果的。在后面的动态生成DOM元素绑定事件就要使用on();]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 比较几种遍历数组及对象的方式]]></title>
    <url>%2F2018%2F05%2F13%2Fjs_4%2F</url>
    <content type="text"><![CDATA[通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历： 方式1：for in 循环1234567891011var arr = [1,2,3,4,5];var obj = &#123; a : 1, b : 2, c : 3 &#125;;for( var item in arr|obj )&#123; fn(item)&#123; // do sth with arr[item]; //do sth wtih obj[item]; &#125;;&#125;这里的 item： array 的索引值，对应于 arr 的下标值； object 的 key 值，对应于 obj 的 a,b,c； 方式2：for 循环123for (var i=0; i&lt;arr.length; i++)&#123; //do sth with arr[i];&#125; 这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题。在方式1中，for-in 需要分析出array 的每个属性，这个操作性能开销很大。用在 key 已知的数组上是非常不划算的。所以尽量不要用 for-in，除非你不清楚要处理哪些属性，例如 JSON 对象这样的情况。在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 array 里存放的都是 DOM 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低。所以这时候我们就有必要对方式2进行优化。 加速的12345var arr = [1,2,3,4,5];var length =arr.length;for(var i=0; i&lt;length; i++)&#123; fn(arr[i]);&#125; 现在只需要读取一次 array 的 length 属性，速度已经加快了。但是还能不能更快呢？事实是，如果循环终止条件不进行比较运算，那么循环的速度还可以更快。 加速且优雅的12345var arr = [1,2,3,4,5];var i = arr.length;while(i--)&#123; fn(arr[i]);&#125; 方式 3：forEach123456var arr = [1,2,3,4,5];arr.forEach( fn(value,index)&#123; //Do sth with value ; &#125;) 注意：这里的 forEach回调中两个参数分别为 value，index，其位置刚好和 jQuery 的$.each 相反；forEach 无法遍历对象；IE不支持该方法；Firefox 和 chrome 支持；forEach 无法使用 break，continue 跳出循环，且使用 return 是跳过本次循环；可以添加第二个参数，为一个数组，回调中的 this 会指向这个数组，若没有添加，则是指向 window； 关于跳出循环的几种方式： return ==》结束循环并中断函数执行； break ==》结束循环函数继续执行； continue ==》跳过本次循环； for 循环中的变量 i，由于 ES5并没有块级作用域的存在，它在循环结束以后仍然存在于内存中，所以建议使用函数自执行的方式来避免。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js与jquery关于验证页面元素存在的方法及不同之处]]></title>
    <url>%2F2018%2F05%2F05%2Fjs_3%2F</url>
    <content type="text"><![CDATA[在javascript中我们可以通过以下代码判断页面中是否存在某个元素 1234obj = document.getElementById(&quot;someID&quot;);if (obj) &#123; obj.innerText(&quot;Extsts&quot;);&#125; 那么在jQuery，我们如何判断页面元素存在与否呢？如果参照上面的传统Javascript的写法，我们第一个想到的办法会是： 123if ($(&quot;#someID&quot;))&#123; $(&quot;#someID&quot;).text(&quot;hi&quot;);&#125; 可是这么写是不对的！因为jQuery对象永远都有返回值，所以$(“someID”) 总是TRUE ，IF语句没有起到任何判断作用。我们知道，jQuery选择器获取页面的element时，无论element是否存在，都会返回一个对象。例如：1var my_element = $(&quot;#element_Id&quot; ); 此时的变量my_element就是一个对象，既然是一个对象，这个对象就具有length的属性，因此，用以下代码可以判断元素（对象）是否存在 正确的写法应该是：123if ( $(&quot;#someID&quot;).length &gt; 0 ) &#123; $(&quot;#someID&quot;).text(&quot;Extsts&quot;);&#125; 注意 ：判断某个页面元素存在与否在jQuery实际上是没有必要的，jQuery本身会忽略 对一个不存在的元素进行操作，并且不会报错, 所以这么写代码会存在bug。假如不存在someID这个元素，我们照样可以执行一下代码，并不会报错。 123456var value=$(&apos;#someID&apos;).length;if(value&gt;0)&#123; alert(&apos;Extsts&apos;);&#125;else&#123; alert(&apos;not Extsts&apos;);&#125; JS判断变量是否为空或是否null1234567/** * 判断是否null * @param data */ function isNull(data)&#123; return (data == &quot;&quot; || data == undefined || data == null) ? &quot;暂无&quot; : data; &#125;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery对于父子、同级元素的处理方式]]></title>
    <url>%2F2018%2F05%2F01%2Fjs_2%2F</url>
    <content type="text"><![CDATA[上一节介绍了一些关于表单处理的元素内容本节介绍jquery对于父、同级、子元素的处理方式。 父窗口与子窗口处理123456789101112131415父窗口：&lt;input name=&apos;img&apos; type=&apos;text&apos; /&gt;&lt;img id=&apos;img&apos; src=&apos;&apos; /&gt;layer.open(&#123; type: 2, title: &apos;title&apos;, area: [&apos;500px&apos;, &apos;350px&apos;], content &apos;son.html&apos;&#125;)子窗口：var img_url;parent.$(&quot;input[name=&apos;img&apos;]&quot;).val(img_url);parent.$(&apos;#img&apos;).attr(&apos;src&apos;, img_url);parent.layer.closeAll(); jQuery获取父元素节点、子元素节点及兄弟元素节点的方法123456789&lt;ul class=&quot;par&quot;&gt; &lt;li id=&quot;firstli&quot;&gt; &lt;h3 class=&quot;title&quot;&gt;one&lt;/h3&gt; &lt;ul class=&quot;par&quot;&gt; &lt;li id=&quot;one&quot;&gt;one_first&lt;/li&gt; &lt;li&gt;two_first&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; jquery父节点的获取使用parent()获取父节点123$(&quot;#one&quot;).parent().parent(); // 获取 id为firstli的li标签节点$(&quot;#one&quot;).parent().parent(&apos;.par&apos;); // 获取最上面 class为par的ul节点$(&quot;#one&quot;).parent(&apos;.par&apos;); // 获取 id为one的上一级class为par的ul节点 使用parents()和closest()获取父节点 closest从当前元素开始匹配寻找，逐级向上寻找直到找到匹配的元素后就停止了，返回0或者1个元素 parents从父元素开始匹配寻找，一直向上查找直到找到根元素，将所有元素放到另外一个集合中，返回0、1或者更多元素12$(&quot;#one&quot;).parnets(&apos;.par&apos;); // 找出所有class为par的父节点/父父节点$(&quot;one&quot;).closest(&apos;.par&apos;); // 获取最近一层的父级class为par的ul节点 jquery兄弟节点的获取parent父节点再find子节点1$(&apos;.title&apos;).parent().find(&apos;ul&apos;); // 找到class为title的兄弟节点ul，即class为par的ul sibingls()获取兄弟节点1$(&apos;.title&apos;).sibings(&apos;ul&apos;); // 找到class为title的兄弟节点ul，即class为par的ul jquery子节点的获取:first方式1$(&apos;.par:first-child&apos;); // 获取id为firstli的li节点 选择器获取1$(&apos;#firstli h3.title&apos;); // 获取class为title的h3节点 find()函数1$(&apos;#firstli&apos;).find(&apos;h3&apos;); // 获取class为title的h3节点 children()函数1$(&apos;#firstli&apos;).children(&apos;h3.title&apos;); // 获取class为title的h3节点]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery获取表单值及属性内容]]></title>
    <url>%2F2018%2F04%2F21%2Fjs_1%2F</url>
    <content type="text"><![CDATA[平时前端在处理表单数据的时候，总是需要通过表单属性或者值来进行一些用户看不到的处理。比如：联动选项的处理、数据的验证过滤等。本节针对不同的表单内容进行了不同的获取方式。 获取当前表单元素的值1234567&lt;input type=&quot;text&quot; name=&quot;name&quot; onblur=&quot;getValue(this)&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; function getValue(obj)&#123; // 获取值 $(obj).val(); &#125;&lt;/script&gt; 获取表单元素值及属性内容123456789101112131415161718192021&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;select name=&quot;sex&quot; data-type=&quot;sex&quot; field=&quot;sex&quot;&gt; &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt;&lt;/select&gt;&lt;script type=&quot;text/javascript&quot;&gt; function do_submit(obj)&#123; // 获取值 var name = $(&quot;input[name=&apos;name&apos;]&quot;).val(); var sex_value = $(&quot;select[name=&apos;sex&apos;]&quot;).val(); // 获取特定文本值的数据 $(&apos;select[name=&quot;data[select]&quot;] [value=&quot;man&quot;]&apos;).val(); // 获取文本值 var sex_text = $(&quot;select[name=&apos;sex&apos;]&quot;).find(&apos;option:selected&apos;).text(); // 获取data-type属性值 var sex_type = $(&quot;select[name=&apos;sex&apos;]&quot;).data(&apos;type&apos;); var sex_type = $(&quot;select[name=&apos;sex&apos;]&quot;).attr(&apos;data-type&apos;); // 获取field属性值 var sex_field = $(&quot;select[name=&apos;sex&apos;]&quot;).attr(&apos;field&apos;); &#125;&lt;/script&gt; 获取多个多行文本框内容值123456789&lt;textarea name=&quot;formula[]&quot; class=&quot;text&quot;&gt;&lt;/textarea&gt;&lt;textarea name=&quot;formula[]&quot; class=&quot;text&quot;&gt;&lt;/textarea&gt;&lt;textarea name=&quot;formula[]&quot; class=&quot;text&quot;&gt;&lt;/textarea&gt;&lt;script type=&quot;text/javascript&quot;&gt; var formula = new Array(); $(&quot;.text,textarea&quot;).each(function(e)&#123; formula.push($(this).val()); &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换电脑后的博客续写]]></title>
    <url>%2F2018%2F04%2F04%2Fchange_do_hexo%2F</url>
    <content type="text"><![CDATA[当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:zhipenwang/zhipenwang.github.io.git拷贝仓库（默认分支为master）； 在本地新拷贝的http://zhipenwang.github.io文件夹下通过Git bash依次执行下列指令： 123npm install hexonpm installnpm install hexo-deployer-git （记得，不需要hexo init这条指令）。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 误删分支恢复方法]]></title>
    <url>%2F2018%2F03%2F28%2Fgit_recover_branch%2F</url>
    <content type="text"><![CDATA[在使用git的时候，有时候会因为人为因素导致分支（commit）被删除，可以使用如下步骤进行恢复。 首先使用以下步骤创建一个新分支，修改一些文件后删除，以便进行恢复1、创建分支hexo1git branch hexo 2、查看分支列表123git branch -a * master hexo 3、切换到hexo分支，随便修改一下东西后commit123456git checkout hexoecho &apos;hexo&apos; &gt; test.txtgit add .git commit -m &apos;add test.txt&apos; 4、删除分支1git branch -D hexo 5、查看分支列表，hexo分支已经不存在12git branch -a * master 恢复步骤如下1、使用git log -g 找回之前提交的commit1234567commit 3eac14d05bc1264cda54a7c21f04c3892f32406aReflog: HEAD@&#123;1&#125; (fdipzone &lt;fdipzone@sina.com&gt;)Reflog message: commit: add test.txtAuthor: fdipzone &lt;fdipzone@sina.com&gt;Date: Sun Jan 31 22:26:33 2016 +0800 add test.txt 2、使用 git branch recover_branch[新分支] commit_id 命令，用这个commit创建一个分支12345git branch recover_branch_hexo 3eac14d05bc1264cda54a7c21f04c3892f32406agit branch -a* master recover_branch_hexo 这个时候，可以看到 recover_branch_hexo分支已经创建了。3、切换到recover_branch_hexo分支，检查文件是否存在12git checkout recover_branch_hexols -lt 这样就可以恢复误删除的分支了。]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 配置ssh密钥]]></title>
    <url>%2F2018%2F03%2F27%2Fssh_key%2F</url>
    <content type="text"><![CDATA[在github帐号注册好之后，将项目clone到本地，加入git bash命令。1、输入cd ~/.ssh 回车，查看是否有ssh key密钥，有了就备份 2、创建ssh key，输入下面命令回车，之后会让你输入github的账号密码，如图12345ssh-keygen -t rsa -C &quot;youremail@youremail.com&quot;Creates a new ssh key using the provided email # Generating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa): 直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)：1Enter same passphrase again: [Type passphrase again] 完了之后，大概是这样：12Your public key has been saved in /home/you/.ssh/id_rsa.pub.The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com 3、找到本地id_rsa.pub文件，复制里面的内容，这就是ssh密钥，可以通过pwd命令来查看当前文件位置 4、登录github，在个人中心的setting中，找到 SSH and GPG keys 点击 new ssh key，将复制的ssh密钥粘贴进 “key”文本框，title随便输入即可。点击add key。添加ssh密钥到远程仓库完成。5、验证ssh是否可用1ssh -T git@github.com 返回如下表示正常可用。1Hi xxx! You&apos;ve successfully authenticated, but GitHub does not # provide shell access. 6、此时查看你的远程分支地址是否是ssh协议的123git remote -vorigin https://github.com/zhipenwang/zhipenwang.git (fetch)origin https://github.com/zhipenwang/zhipenwang.git (push) 如果是https协议，修改为ssh协议：1git remote set-url origin git@github.com:zhipenwang/zhipenwang.git 这个时候就可以进行push了。]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始算法]]></title>
    <url>%2F2018%2F02%2F13%2Falgorithm%2F</url>
    <content type="text"><![CDATA[算法：程序的灵魂 算法：algorithm 算法五大特征： 1、有穷性：保证执行有限步骤后结束 2、确切性：每一步骤都有确切的意义 3、输入：每个算法都有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身定除了初始条件 4、输出：每个算法都有一个或多个输出，显示对输入数据加工后的结果。没有输出的算法是毫无意义的 5、可行性：在原则上算法能够精确地运行，进行优先次运算后即可完成的一种运算。 算法的逻辑、流程。计算机中的算法，分为两大类：数值运算算法（求解数值）、非数值运算算法（事务管理领域）。算法是计算机处理信息的本质，因为计算机程序本质上是一个算法，告诉计算机确切的步骤来执行一个指定的任务。 著名计算机科学家沃思公式：数据结构+算法=程序。 一个程序应当采用结构化程序设计方法进行程序设计，并且用某一种计算机语言来表示，因此，下面的公式更加贴切： 程序=算法+数据结构+程序设计方法+语言和环境 流程图来表示算法： 流程图的结构：顺序结构、选择结构、循环结构 N-S图 N-S流程图：代表计算机的算法。由一些特定意义的图像、流程线及简要的文字说明构成，能够清晰明确的表示程序的运行过程。（整个程序写在一个大框图内，由若干个小的基础框图构成，简称N-S图） 计算机语言的算法表示计算机语言表示算法的时候，必须严格遵循使用语言的语法规则。 学好算法的秘诀1、学的深入，基础扎实2、恒心、演练、举一反三3、语言之争的时代更要学会坚持]]></content>
      <categories>
        <category>算法与结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer安装与使用]]></title>
    <url>%2F2017%2F04%2F21%2Fcomposer-1%2F</url>
    <content type="text"><![CDATA[安装1、点击下载：composer 2、下载好之后双击直接安装，Next即可：3、然后选择php.exe文件： 接下来就一直next到安装完成即可。 使用 [info]使用composer安装ThinkPHP5 通过composer中国镜像进行初步了解 ##开始命令行操作 1、中国镜像下载参考tp5看云文档 由于国外网站访问很慢，国内提供了很好的镜像，所以使用国内镜像：1Composer config -g repo.packagist composer https://packagist.phpcomposer.com 2、下载tp5框架进入站点根目录www操作命令行：1composer create-project topthink/think tp5 --prefer-dist 其中tp5可写填写任何你愿意的名称 框架安装完成耐心等待几分钟的安装过程，安装完成之后本地已经生成了tp5的新框架内容 composer主要的功能：安装扩展包composer的最主要的功能：dependency manager for PHP进入项目目录tp5，执行命令：1composer require riverslei/payment 下载riverslei/payment 集成支付宝、微信支付等流行的支付接口到项目中：Composer.json中新增了这一句： 项目目录中也已经安装好了扩展包：]]></content>
      <categories>
        <category>composer使用</category>
      </categories>
      <tags>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer构建PHP框架——构建路由]]></title>
    <url>%2F2017%2F04%2F21%2Fcomposer-3%2F</url>
    <content type="text"><![CDATA[路由选择安装本节开始构建路由，先去 GitHub 搜一下：点此查看搜索结果 推荐 https://github.com/NoahBuscher/Macaw，对应的 Composer 包为 noahbuscher/macaw 。 下面开始安装它，更改 composer.json：12345&#123; &quot;require&quot;:&#123; &quot;noahbuscher/macaw&quot;: &quot;dev-master&quot; &#125;&#125; 运行 composer update，成功之后将得到以下目录： 至此，Macaw安装成功！ 站点入口文件与环境在项目目录下新建public 文件夹，这个文件夹将是用户唯一可见的部分。在文件夹下新建 index.php 文件：1234567&lt;?php// Autoload 自动载入require &apos;../vendor/autoload.php&apos;;// 路由配置require &apos;../config/routes.php&apos;; 上面一行表示引入 Composer 的自动载入功能，下面一行表示载入路由配置文件。然后继续在项目目录下新建config文件夹，在config文件夹内新建 routs.php 文件，内容如下：12345678910111213&lt;?phpuse NoahBuscher\Macaw\Macaw;Macaw::get(&apos;fuck&apos;, function() &#123; echo &quot;成功！&quot;;&#125;);Macaw::get(&apos;(:all)&apos;, function($fu) &#123; echo &apos;未匹配到路由&lt;br&gt;&apos;.$fu;&#125;);Macaw::dispatch(); 然后访问你的地址即可：http://127.0.0.66/index.php/fuck 注意：如果要配置域名地址进行映射要指向 public/index.php 文件]]></content>
      <categories>
        <category>composer使用</category>
      </categories>
      <tags>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer构建PHP框架——初始化]]></title>
    <url>%2F2017%2F04%2F21%2Fcomposer-2%2F</url>
    <content type="text"><![CDATA[“一个时代结束了，另一个时代开始了。”Framework Interoperability Group（框架可互用性小组），简称 FIG，成立于 2009 年。FIG 最初由几位知名 PHP 框架开发者发起，在吸纳了许多优秀的大脑和强健的体魄后，提出了 PSR-0 到 PSR-4 五套 PHP 非官方规范： 123456789* PSR-0 (Autoloading Standard) 自动加载标准* PSR-1 (Basic Coding Standard) 基础编码标准* PSR-2 (Coding Style Guide) 编码风格向导* PSR-3 (Logger Interface) 日志接口* PSR-4 (Improved Autoloading) 自动加载优化标准 创建composer.json在网站根目录下创建新文件夹 my-framework （My First Framework based on Composer），然后在此文件夹内创建 composer.json 文件12345&#123; &quot;require&quot;:&#123; &#125;&#125; 初始化composer打开命令行cmd，进入刚刚新建的目录 my_framework，执行命令1composer update 执行成功后生成了扩展包vendor 此时目录为： 到此，composer初始化完成！]]></content>
      <categories>
        <category>composer使用</category>
      </categories>
      <tags>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题内接入网页在线联系功能]]></title>
    <url>%2F2017%2F04%2F20%2Fconnect%2F</url>
    <content type="text"><![CDATA[Hexo博客如何添加在线联系功能呢,发现了一个不错的网站可以提供在线联系的服务，当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。 注册首先在(DaoVoice)[http://www.daovoice.io/]注册个账号。登录上去之后进行配置，配置方法如下:首先到DaoVoice上注册一个账号,注册完成后会得到一个app_id，获取appid的步骤如下图所示: 以next主题为例,打开/themes/next/layout/_partials/head.swig文件添加如下代码：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 接着打开主题配置文件_config.yml，添加如下代码：123# Online contact daovoice: truedaovoice_app_id: 这里输入前面获取的app_id 需要注意的是,next主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置:最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，就可以实时收发消息，有新的消息也会通过微信通知，设置页面如下:]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加字数统计、阅读时长、浏览次数]]></title>
    <url>%2F2017%2F04%2F19%2Fblog_view%2F</url>
    <content type="text"><![CDATA[统计插件配置NexT 主题默认已经集成了文章【浏览次数】、【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要修改主题配置文件 _config.yml 即可。如下所示：配置浏览次数123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访问人数 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 总访问量 site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 浏览 page_pv_footer: 次 配置字数统计、阅读时长，wordcount与min2read统计功能12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: false # 网站 字数统计 separated_meta: true 预览的时候如果出现字数统计和阅读时长失效的情况，一般是因为没有安装 hexo-wordcount 插件，查看 Hexo 插件：12345hexo --debug``### 安装如果没有安装 hexo-wordcount 插件，先安装该插件： npm i –save hexo-wordcount1*** Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下：*** npm install hexo-wordcount@2 –save`安装完成后，重新执行启动服务预览就可以了。 显示文字打开post.swig文件，路径如下：xxx_blog/themes/next/layout/_macro/post.swig]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题内给每篇文章后添加结束标语]]></title>
    <url>%2F2017%2F04%2F18%2Fhexo_next_end%2F</url>
    <content type="text"><![CDATA[给文章后面添加结束标语 新建文件在\themes\next\layout\_macro中新建passage-end-tag.swig文件，添加代码至该文件中：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:22px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 修改post.swig打开\themes\next\layout_macro\post.swig文件，在post-body后，post-footer前，添加下面内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改_config打开主题配置文件（_config.yml),在末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 至此，就完成了关于添加文章结束标语的功能，具体的效果，此刻，想必你也看到了，就在下边。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题添加点击爱心效果]]></title>
    <url>%2F2017%2F04%2F17%2Fclickheart%2F</url>
    <content type="text"><![CDATA[给NexT主题内添加页面点击出现爱心的效果 创建js文件在/themes/next/source/js/src下新建文件clicklove.js，接着把该链接下的代码拷贝粘贴到clicklove.js文件中。代码如下：1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 修改_layout.swig在\themes\next\layout\_layout.swig文件末尾添加：12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo在其他设备或系统上续写]]></title>
    <url>%2F2017%2F03%2F20%2Fhexo_change_system%2F</url>
    <content type="text"><![CDATA[注意：需要将原系统中的原项目所有内容都发布到github上新系统需要安装node、git 新系统中git clone blog@github.com到本地 新系统中切换分支 git checkou branch 安装hexo：npm install hexo 初始化：npm install; npm install hexo-deployer-git 然后就可以执行hexo：hexo clean; hexo g; hexo s]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo发布文章]]></title>
    <url>%2F2017%2F03%2F19%2Fhexo_new_blog%2F</url>
    <content type="text"><![CDATA[在部署和搭建好hexo博客后，怎么写好一篇博客并发布到在线地址呢？ 1、找到你本地的博客地址，在source/_posts目录下新建新文件，后缀为md，写一篇markdown文章2、打开git bash命令端本地预览：1hexo server 提交到git仓库，同步到在线博客123hexo cleanhexo generatehexo deploy 然后就可以在你的博客看到更新的文章了。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建个人博客]]></title>
    <url>%2F2017%2F03%2F18%2Fcreate-blog%2F</url>
    <content type="text"><![CDATA[各位有兴趣搭建博客或者正在搭建博客却遇到问题的朋友们，不妨抽空来围观一下我搭建的过程中遇到的坑和填的土。。 声明一点，以下所有步骤都是基于Windows系统的搭建，由于本人没有真正在其他系统上搭建过，就不画蛇添足了，所以其他系统的小心不要入错入坑咯 下面先说一下基本思路（给大家一个清晰的搭建过程）： 1、在Windows系统下搭建运行hexo环境的前提是先搭建nodejs跟git2、搭建好nodejs跟git后就可以在系统中搭建hexo环境3、申请github.com帐号，创建自己的repository（仓库）——注意仓库名必须是：yourusername.github.io，具体原因及内容后面细讲、4、本地hexo环境部署到github上 5、yourusername.github.io查看自己的博客，成功！ 第一步：搭建nodejs环境参考菜鸟教程的nodejs，很是详细：nodejs-菜鸟教程 大家可以去nodejs官网下载，记得要下载跟自己Windows系统一致的版本。（64bit的下载window-install的64-bit；同理：32bit的下载32-bit的）。下载之后双击安装，选择自己要安装的路径地址，一直next到finish就可以了安装后检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入”cmd” =&gt; 输入命令”path”，输出结果中有nodejs的环境变量说明安装成功。（如下我的环境变量已经有nodejs了）1234PATH=C:\oraclexe\app\oracle\product\10.2.0\server\bin;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;c:\python32\python;C:\MinGW\bin;C:\Program Files\GTK2-Runtime\lib;C:\Program Files\MySQL\MySQL Server 5.5\bin;C:\Program Files\nodejs\; 然后可以检查一下Node.js版本，直接命令行输入 node –versionok，nodejs环境到此完成。 第二步：搭建GIT环境同样，大家可以参考百度经验 下载地址可以前往git官网进行下载，同样下载跟自己系统位数一致的版本下载之后双击选择自己要安装的路径地址一键next安装就好了安装好之后在任意位置右键都可以看到关于git的一些菜单选项：ok，至此git安装完成。 第三步：搭建hexo环境在E盘下建立hexo文件夹（或者你选择的任何路径）在nodejs和git环境都搭建完成后，在刚刚建立好的hexo文件夹中点击鼠标右键，选择git bash，输入以下命令安装hexo1npm install -g hexo 接下来是比较重要的步骤，都是在git bash命令行操作，要认真看清楚： 1、初始化你的博客1hexo init 执行后hexo会在你的站点目录下生成网站所需的文件 2、安装node_modules：1npm install 在此目录中生成node_modules 3、本地浏览器查看：1hexo server (此命令也可以简写为 hexo s) 这时候会出现如下信息：[info] Hexo is running at http://localhost:4000/.Press Ctrl+C to stop. 这个时候在你的浏览器输入http://localhost:4000/你就可以看到本地的博客搭建成功。这个时候可以轻松一下，随便浏览一下自己的博客熟悉一下 第四步：本地hexo部署到github上1、首先要有github帐号，可以前往github官网注册一个自己的github帐号，登录成功后，点击右上角的+号新建一个仓库注意，仓库名必须跟自己的username一致，格式是username.github.io]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的意义]]></title>
    <url>%2F2017%2F03%2F17%2Fblog%2F</url>
    <content type="text"><![CDATA[文中内容仅是个人观点，不喜随便喷，如有雷同，欢迎交流 为什么有开博客的想法呢？作为一名后端攻城狮，在各种“撸码”的过程中经常会碰到一些萝卜坑，当然及时植入了萝卜。开始填的时候也不以为常，管他下次会不会被挖再露出坑，慢慢学习的过程中遇到了更多的坑，觉得有点烧闹了，开始各种方式去学着记录，D、E、F盘塞了各种记录文本，慢慢发现这种方式查阅起来很是麻烦，而且最关键的是，有一次打开我记录了几千行的笔记，结果发现乱码了（原因是一直用gbk去写的，某一次脑短路用了默认utf格式的编辑器打开，整篇文档都乱码，又手贱的去直接在编辑器中点错了其他格式还保存，果然是自作孽不可活），后来各种软件编辑器尝试，越来越不认识其字符了，不过对咱来说，没法补救的东西失去了那就从头再来呗。这个时候开始打算换一种方式来记录一些自己遇到的坑和一些有价值的内容，同时也可以在一个平台上跟其他有深度的人沟通学习成长，所以打算在大平台去搭建一个属于个人的主页。 其中， 新浪博客、QQ空间、CSDN等“个人主页”都流行很久了，所以有越来越多的人开始考虑搭建一个真正属于自己的“个人主页”，个人博客建站也越来越流行。那么搭建个人博客的目的无非是以下几点： 作为一个展示个性的平台搭建一个展示个人观点、爱好、经历的良好平台，跟那些流行的新浪博客和QQ空间不一样，个人博客可以很灵活自由的去设计ownerstyle的网站。 作为一个知识积累的海洋不管是从事文学、管理、IT开发，都可以通过这个平台去记录一些有价值对自己有影响的内容，积累成一个属于自己知识的海洋 作为一个交流分享的平台不仅仅把自己的知识积累下来，更大程度的去分享，了解别人的一些不同看法，沟通完善一些自我的缺陷，学习别人更广的知识 作为一个攻城狮，要时刻去接触互联网新的思想，去真正参与到互联网中，既然决定了写博客，那么自己动手去搭建一个专属的博客，然后一步步去推广，不仅仅会带来前进的动力，其实也会慢慢去接触学习到什么才是真正的SEO（搜索引擎–百度搜索排行其实很大程度就是靠这个），也会去认识到网络推广。对目前的我而言，那就是希望坚持下去，作为一个自我价值的体现，在未来的工作或者社交中能够以这个平台去让别人了解自己，成为自我的一个标识。]]></content>
      <categories>
        <category>博客思维</category>
      </categories>
      <tags>
        <tag>Article</tag>
      </tags>
  </entry>
</search>
