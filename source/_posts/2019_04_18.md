---
title: 深入理解cgi与fastcgi：nginx与fpm的工作机制
date: 2019-04-18
tags: [PHP,Nginx]
categories: PHP
---
*本文主要是讨论Nginx与FPM的工作机制及其配置背后的原理，以此来真正理解Nginx与PHP的协同工作机制。*

> 先来谈谈CGI、FastCGI两个协议及PHP-FPM。
### CGI
CGI是Web Server与后台语言交互的协议。通过此协议，开发者可以使用任何语言处理web server发来的请求，动态的生成内容。  

CGI的工作原理：  
每当客户请求CGI的时候，WEB服务器就请求操作系统生成一个新的CGI解释器进程（如php-cgi.exe），CGI的一个进程处理完一个请求后就退出，下一个请求来时再创建新的进程。

CGI的缺点：  
每处理一个请求都需要fork出一个全新的进程，随着Web的兴起，高并发越来越成为常态，这样低效的方式无法满足需求。于是FastCGI诞生了。

### FastCGI
FastCGI，顾名思义为更快的CGI，允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。  
FastCGI，就像一个常驻（long-live）型的CGI，可以一直执行着，只要激活后，不会每次都要花费时间去fork一次进程（这是CGI最为人诟病的fork-and-execute模式）。  

一般情况下，FastCGI的整个工作流程如下：  
1. Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module）
2. FastCGI进程管理器自身初始化。启动多个CGI解释器进程（可见多个php-cgi）并等待来自Web Server的连接
3. 当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web Server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi

### PHP_FPM
php-fpm是PHP内置的一个FastCGI进程管理器。是一种master（主）/worker（子）多进程架构，与nginx设计风格有点类似。    
master进程只有一个，主要负责CGI及PHP环境初始化、端口监听、事件监听、子进程状态等等，接收来自Web Server的请求；而worker进程则一般有多个（具体数量根据实际需要配置），每个进程内部都嵌入了一个PHP解释器，是PHP代码真正执行的地方，负责处理php请求。

#### 运行模式
在介绍允许原理之前，先了解它的几种运行模式。  
php-fpm支持三种运行模式，分别为static、ondemand、dynamic，默认为dynamic。  
1. static：静态模式，启动时分配固定的worker进程，通过设置pm.max_children固定的worker进程数
2. ondemand：按需分配，当收到用户请求时fork worker进程
3. dynamic：动态模式，启动时分配固定的进程，伴随着请求数增加，在设定的浮动范围调整worker进程

#### 运行原理
php-fpm采用master/worker架构设计，下面详细讲解这两个模块的运行原理。
##### master进程
master进程工作流程分为4个阶段  
1. cgi初始化阶段：分别调用fcgi_init()和 sapi_startup()函数，注册进程信号以及初始化sapi_globals全局变量。 
2. php环境初始化阶段：由cgi_sapi_module.startup 触发。实际调用php_cgi_startup函数，而php_cgi_startup内部又调用php_module_startup执行。   
    php_module_startup主要功能：  
    1. 加载和解析php配置；  
    2. 加载php模块并记入函数符号表(function_table)；  
    3. 加载zend扩展 ;   
    4. 设置禁用函数和类库配置；  
    5. 注册回收内存方法； 
3. php-fpm初始化阶段：执行fpm_init()函数。负责解析php-fpm.conf文件配置，获取进程相关参数（允许进程打开的最大文件数等）,初始化进程池及事件模型等操作。 
4. php-fpm运行阶段：执行fpm_run() 函数，运行后主进程发生阻塞。  
    该阶段分为两部分：fork子进程 和 循环事件。  
    fork子进程部分交由fpm_children_create_initial函数处理（ 注：ondemand模式在fpm_pctl_on_socket_accept函数创建）。  
    循环事件部分通过fpm_event_loop函数处理，其内部是一个死循环，负责事件的收集工作。

##### worker进程
worker进程分为 接收客户端请求、处理请求、请求结束三个阶段。  
1. 接收客户端请求：执行fcgi_accept_request函数，其内部通过调用accept 函数获取客户端请求。
    ```
    //请求锁
    FCGI_LOCK(req->listen_socket);
    req->fd = accept(listen_socket, (struct sockaddr *)&sa, &len);
    //释放锁
    FCGI_UNLOCK(req->listen_socket);
    ```
    从上面的代码，可以注意到accept之前有一个请求锁的操作，这么设计是为了避免请求出现“惊群”的现象。当然，这是一个可选的选项，可以取消该功能。
2. 处理请求阶段：  
    1. 首先，分别调用fpm_request_info、php_request_startup获取请求内容及注册全局变量(GET、_POST、SERVER、_ENV、$_FILES)；  
    2. 然后根据请求信息调用php_fopen_primary_script访问脚本文件；  
    3. 最后交给php_execute_script执行。php_execute_script内部调用zend_execute_scripts方法将脚本交给zend引擎处理。 
3. 请求结束阶段：执行php_request_shutdown函数。此时回调register_shutdown_function注册的函数及__destruct()方法，发送响应内容、释放内存等操作。

#### 整体流程
从FPM接收到请求到处理完毕，其具体流程如下：
1. FPM的master进程接收到请求
2. master进程根据配置指派特定的worker进程进行请求处理，如果没有可用进程，返回错误，这也是在配合Nginx遇到502错误比较多的原因
3. worker进程处理请求，如果超时，返回504错误
4. 请求处理结束，返回结果

> 下面从Nginx层面来说明与fpm的请求处理。
### Nginx与fpm
Nginx不仅仅是一个Web服务器，也是一个功能强大的Proxy服务器，除了进行http请求的代理，也可以进行许多其他协议请求的代理，包括本文与fpm相关的fastcgi协议。  
> 为了能够使 Nginx 理解 fastcgi 协议，Nginx 提供了 fastcgi 模块来将 http 请求映射为对应的 fastcgi 请求。

#### Nginx的fastcgi 模块
1. 提供了 fastcgi_param 指令来主要处理这些映射关系，其主要完成的工作是将 Nginx 中的变量翻译成 PHP 中能够理解的变量。  
2. 提供了 fastcgi_pass 指令，这个指令用于指定 fpm 进程监听的地址，Nginx 会把所有的 php 请求翻译成 fastcgi 请求之后再发送到这个地址

下面是一个简单的可用工作的Nginx配置文件。
```
server {
    listen       80;
    server_name  localhost;
    root         /data/code/www;

    location / {
        root   /data/code/www;
        index  index.php index.html index.htm;
    }

    location ~ \.php$ {
        root            /data/code/www;
        fastcgi_index   index.php;
        fastcgi_pass    phpfpm_backend;
        include         fastcgi_params;
        fastcgi_param   SCRIPT_FILENAME  $document_root$fastcgi_script_name;
        #fastcgi_param  SCRIPT_NAME      $fastcgi_script_name;
    }
}
```
> 在这个配置文件中，新建了虚拟主机:  
监听80端口,  
Web根目录为：/data/code/www，  
通过location指令，将所有的以.php结尾的文件都交给了fastcgi模块去处理，从而将所有的php求都交给了fpm处理，  
完成了Nginx到fpm的闭环。

希望通过本文，能够让大家对Nginx与FPM通信的整个流程比较清晰。