---
title: PHP与KAFKA的两种消费方式
date: 2019-06-23
tags: [KAFKA,PHP]
categories: KAFKA
---

KAFKA的低级消费
> 多次读取同一个消息
1. 指定消费Topic Partition的Leader broker及备份broker；
2. 构造并发送请求数据；
3. 处理leader broker的变更；
```
<?php

$rk = new RdKafka\Consumer();
$rk->setLogLevel(LOG_DEBUG);
$rk->addBrokers("127.0.0.1:9092");

$topic = $rk->newTopic("na-fleeper-users-profile");

$topic->consumeStart(0, RD_KAFKA_OFFSET_BEGINNING);

while (true) {
    $msg = $topic->consume(0, 1000);
    if(isset($msg->err) && $msg->err){
        echo $msg->errstr() . "\n";
        break;
    } elseif(isset($msg->payload) && $msg->payload) {
        echo $msg->payload . "\n";
    }
}
```

KAFKA的高级消费
1. 同一个消费群组中，如果线程数大于Topic分区数，那么一些线程永远接收不到消息；
2. 同一个消费群组中，如果线程数小于Topic分区数，部分线程将从多个分区接收消息；
3. 对于从多个分区接收消息的线程，消费每个分区内的消息是有序的，但消费多个分区之间的消息是无序的；
```
<?php

$conf = new RdKafka\Conf();

$conf->setRebalanceCb(function (RdKafka\KafkaConsumer $kafka, $err, array $partitions = null) {
   switch ($err) {
       case RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS:
           echo "Assign: ";
           var_dump($partitions);
           $kafka->assign($partitions);
           break;
       case RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS:
           echo "Revoke: ";
           var_dump($partitions);
           $kafka->assign(NULL);
           break;
       default:
           throw new \Exception($err);
   }
});

$conf->set('group.id', "myConsumerGroup");
$conf->set("metadata.broker.list", "127.0.0.1:9092");
$topicConf = new RdKafka\TopicConf();
$topicConf->set('auto.offset.reset', 'smallest');
$conf->setDefaultTopicConf($topicConf);

$consumer = new RdKafka\KafkaConsumer($conf);

$consumer->subscribe(["test_nginx"]);

while (true) {
    $message = $consumer->consume(120*1000);
    switch ($message->err) {
        case RD_KAFKA_RESP_ERR_NO_ERROR:
            var_dump($message);
            break;
        case RD_KAFKA_RESP_ERR__PARTITION_EOF:
            echo "No more message; will wait for more\n";
            break;
        case RD_KAFKA_RESP_ERR__TIMED_OUT:
            echo 'Timed out\n';
            break;
        default:
            throw new \Exception($message->errstr(), $message->err);
            break;
    }
}
```