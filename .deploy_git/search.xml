<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jQuery的三种bind/One/Live/On事件绑定使用方法]]></title>
    <url>%2F2018%2F05%2F20%2Fjs_5%2F</url>
    <content type="text"><![CDATA[on(events,[selector],[data],fn) events:一个或多个用空格分隔的事件类型和可选的命名空间，如”click”或”keydown.myPlugin” 。selector:一个选择器字符串用于过滤器的触发事件的选择器元素的后代。如果选择器为null或省略，当它到达选定的元素，事件总是触发。data:当一个事件被触发时要传递event.data给事件处理函数。fn:该事件被触发时执行的函数。 false 值也可以做一个函数的简写，返回false 替换bind() 当第二个参数’selector’为null时，on()和bind()其实在用法上基本上没有任何区别了，所以我们可以认为on()只是比bind()多了一个可选的’selector’参数，所以on()可以非常方便的换掉bind() 替换live() 在1.4之前相信大家非常喜欢使用live(),因为它可以把事件绑定到当前以及以后添加的元素上面，当然在1.4之后delegate()也可以做类似的事情了。live()的原理很简单，它是通过document进行事件委派的，因此我们也可以使用on()通过将事件绑定到document来达到live()一样的效果。 live()写法1234$(&apos;#list li&apos;).live(&apos;click&apos;, &apos;#list li&apos;, function() &#123; //function code here.&#125;); on()写法12345$(document).on(&apos;click&apos;, &apos;#list li&apos;, function() &#123; //function code here.&#125;); 这里的关键就是第二个参数’selector’在起作用了。它是一个过滤器的作用，只有被选中元素的后代元素才会触发事件。 替换delegate() delegate()是1.4引入的，目的是通过祖先元素来代理委派后代元素的事件绑定问题，某种程度上和live()优点相似。只不过live()是通过document元素委派，而delegate则可以是任意的祖先节点。使用on()实现代理的写法和delegate()基本一致。 delegate()的写法1234$(&apos;#list&apos;).delegate(&apos;li&apos;, &apos;click&apos;, function() &#123; //function code here.&#125;); on()写法1234$(&apos;#list&apos;).on(&apos;click&apos;, &apos;li&apos;, function() &#123; //function code here.&#125;); 貌似第一个和第二个参数的顺序颠倒了一下，别的基本一样。 总结 jQuery推出on()的目的有2个，一是为了统一接口，二是为了提高性能，所以从现在开始用on()替换bind(),live(),delegate吧。尤其是不要再用live()了，因为它已经处于不推荐使用列表了，随时会被干掉。如果只绑定一次事件，那接着用one()吧，这个没有变化。jQuery是 一款优秀的JavaScript框架,在旧版里主要用bind()方法，在新版里又多了两种One(),Live()下面介绍这几种方法的使用： 1. bind/Unbind 在jquery的事件模型中，有两个基本的事件绑 定函数，bind与unbind，这两个函数的含义就是匹配页面元素进行相关事件的处理。比如我们在JS中经常使用到的 onfocus，onblur，onmouseover，onmousedown等事件都可以作为bind的参数进行传递。$(“#id”).bind(‘click’,function(){alert(‘tt!’)});其中bind的第一个参数代表的含义是：事件类型(注意不需要加on)，function中的代码就是你要执行的逻辑 代码多个事件绑定：bind还允许你绑定多个事件，事件名字之间用空格隔开，例如：$(‘a’).bind(‘click mouseover’,function(){在最新的jquery1.4版本中，对bind方法进行了改进，你可以在bind方法传入一个类JSON对象来一次绑定多 个事件处理函数。12345678$(&apos;a&apos;).bind(&#123; click:function()&#123; alert(&apos;a&apos;); &#125;, mouseover:function()&#123; alert(&apos;a again!&apos;) &#125;&#125;) 在function函数中，你还可以通过传递一个javaScript对 象给function方法，这个事件对象通常是可以省略的。bind中还有一个参数data， 该参数一般情况下很少使用，通常为了解决在同一个方法中处理同一个变量时有很好的处理。12345678var productname=&quot;Sports Shoes&quot;; $(&apos;#Area&apos;).bind(&apos;click&apos;,function()&#123; alert(productname);&#125;);productname=&quot;necklace&quot;,$(&apos;#Area&apos;).bind(&apos;click&apos;,function()&#123; alert(productname);&#125;); 由于变量productname被重新赋值，所以输出的消息都是”necklace”,这里不了解可以去查阅下关于JavaScript的变量作用域,要 解决这个问题就必须使用到data参数，12345678var productname=&quot;Sports Shoes&quot;;$(&apos;#Area&apos;).bind(&apos;click&apos;,&#123;pn:productname&#125;,function()&#123; alert(event.data.pn);&#125;);productname=&quot;necklace&quot;,$(&apos;#Area&apos;).bind(&apos;click&apos;,&#123;pn:productname&#125;,function()&#123; alert(event.data.pn);&#125;); 2. One为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。该方法与bind方法的参数一样，与bind方法的区别就是只对匹配元素的事 件处理执行一次，执行完之后，以后再也不会执行,当然重新发起web请求时它又会执行一次。123$(&apos;a&apos;).one(&apos;click&apos;,function()&#123; alert(&apos;a&apos;);&#125;) 单击页面上的a元素后，弹出消息，除非用户发起第二次请求，否则再次点击a元素不会弹出消息对话框。 3. live该方法主要是能处理动态添加的元素，给那些后添加的元素也一样绑定事件。123$(&apos;a&apos;).live(&apos;click,function()&#123; alert(&apos;show message!&apos;);&#125;) 然后如果我添加一个元素，$(‘body’).appnend(‘Another Element’);那么该元素也会被触发事件处理函数alert。另外，jQuery还提供了一些绑定这些标准事件类型的简单方式，比如.click()用于简化.bind(‘click’)。一共有以下这些事件名称：blur, focus, focusin, focusout, load, resize, scroll, unload, click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout, mouseenter, mouseleave, change, select, submit, keydown, keypress, keyup, error 等。下面看下jQuery中绑定事件bind() on() live() one()的异同jQuery中绑定事件的四种方法，他们可以同时绑定一个或多个事件1234bind()----------版本号小于3.0（在Jquery3.0中已经移除，相应unbind()也移除）live()----------版本号小于1.7（在Jquery1.7中已经移除，相应die()也移除）delegate()------版本号小于1.7（在Jquery1.7中已经移除）on()------------版本号大于1.7（在Jquery1.7中添加，相应off()也添加） A：bind()事件的用法12345678910111213141516171819&lt;title&gt;绑定事件&lt;/title&gt; &lt;script src=&quot;js/jQuery1.11.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&quot;p&quot;).bind(&#123; &quot;mouseover&quot;: function () &#123; $(&quot;p&quot;).css(&quot;background-color&quot;, &quot;red&quot;); &#125;, &quot;mouseout&quot;: function () &#123; $(&quot;p&quot;).css(&quot;background-color&quot;, &quot;&quot;); &#125; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;what are you doing?&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 第一个最大的区别就是：bind()的事件绑定是只对当前页面选中的元素有效。如果你想对动态创建的元素bind()事件，是没有办法达到效果的。在后面的动态生成DOM元素绑定事件就要使用on();]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 比较几种遍历数组及对象的方式]]></title>
    <url>%2F2018%2F05%2F13%2Fjs_4%2F</url>
    <content type="text"><![CDATA[通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历： 方式1：for in 循环1234567891011var arr = [1,2,3,4,5];var obj = &#123; a : 1, b : 2, c : 3 &#125;;for( var item in arr|obj )&#123; fn(item)&#123; // do sth with arr[item]; //do sth wtih obj[item]; &#125;;&#125;这里的 item： array 的索引值，对应于 arr 的下标值； object 的 key 值，对应于 obj 的 a,b,c； 方式2：for 循环123for (var i=0; i&lt;arr.length; i++)&#123; //do sth with arr[i];&#125; 这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题。在方式1中，for-in 需要分析出array 的每个属性，这个操作性能开销很大。用在 key 已知的数组上是非常不划算的。所以尽量不要用 for-in，除非你不清楚要处理哪些属性，例如 JSON 对象这样的情况。在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 array 里存放的都是 DOM 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低。所以这时候我们就有必要对方式2进行优化。 加速的12345var arr = [1,2,3,4,5];var length =arr.length;for(var i=0; i&lt;length; i++)&#123; fn(arr[i]);&#125; 现在只需要读取一次 array 的 length 属性，速度已经加快了。但是还能不能更快呢？事实是，如果循环终止条件不进行比较运算，那么循环的速度还可以更快。 加速且优雅的12345var arr = [1,2,3,4,5];var i = arr.length;while(i--)&#123; fn(arr[i]);&#125; 方式 3：forEach123456var arr = [1,2,3,4,5];arr.forEach( fn(value,index)&#123; //Do sth with value ; &#125;) 注意：这里的 forEach回调中两个参数分别为 value，index，其位置刚好和 jQuery 的$.each 相反；forEach 无法遍历对象；IE不支持该方法；Firefox 和 chrome 支持；forEach 无法使用 break，continue 跳出循环，且使用 return 是跳过本次循环；可以添加第二个参数，为一个数组，回调中的 this 会指向这个数组，若没有添加，则是指向 window； 关于跳出循环的几种方式： return ==》结束循环并中断函数执行； break ==》结束循环函数继续执行； continue ==》跳过本次循环； for 循环中的变量 i，由于 ES5并没有块级作用域的存在，它在循环结束以后仍然存在于内存中，所以建议使用函数自执行的方式来避免。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js与jquery关于验证页面元素存在的方法及不同之处]]></title>
    <url>%2F2018%2F05%2F05%2Fjs_3%2F</url>
    <content type="text"><![CDATA[在javascript中我们可以通过以下代码判断页面中是否存在某个元素 1234obj = document.getElementById(&quot;someID&quot;);if (obj) &#123; obj.innerText(&quot;Extsts&quot;);&#125; 那么在jQuery，我们如何判断页面元素存在与否呢？如果参照上面的传统Javascript的写法，我们第一个想到的办法会是： 123if ($(&quot;#someID&quot;))&#123; $(&quot;#someID&quot;).text(&quot;hi&quot;);&#125; 可是这么写是不对的！因为jQuery对象永远都有返回值，所以$(“someID”) 总是TRUE ，IF语句没有起到任何判断作用。我们知道，jQuery选择器获取页面的element时，无论element是否存在，都会返回一个对象。例如：1var my_element = $(&quot;#element_Id&quot; ); 此时的变量my_element就是一个对象，既然是一个对象，这个对象就具有length的属性，因此，用以下代码可以判断元素（对象）是否存在 正确的写法应该是：123if ( $(&quot;#someID&quot;).length &gt; 0 ) &#123; $(&quot;#someID&quot;).text(&quot;Extsts&quot;);&#125; 注意 ：判断某个页面元素存在与否在jQuery实际上是没有必要的，jQuery本身会忽略 对一个不存在的元素进行操作，并且不会报错, 所以这么写代码会存在bug。假如不存在someID这个元素，我们照样可以执行一下代码，并不会报错。 123456var value=$(&apos;#someID&apos;).length;if(value&gt;0)&#123; alert(&apos;Extsts&apos;);&#125;else&#123; alert(&apos;not Extsts&apos;);&#125; JS判断变量是否为空或是否null1234567/** * 判断是否null * @param data */ function isNull(data)&#123; return (data == &quot;&quot; || data == undefined || data == null) ? &quot;暂无&quot; : data; &#125;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery对于父子、同级元素的处理方式]]></title>
    <url>%2F2018%2F05%2F01%2Fjs_2%2F</url>
    <content type="text"><![CDATA[上一节介绍了一些关于表单处理的元素内容本节介绍jquery对于父、同级、子元素的处理方式。 父窗口与子窗口处理123456789101112131415父窗口：&lt;input name=&apos;img&apos; type=&apos;text&apos; /&gt;&lt;img id=&apos;img&apos; src=&apos;&apos; /&gt;layer.open(&#123; type: 2, title: &apos;title&apos;, area: [&apos;500px&apos;, &apos;350px&apos;], content &apos;son.html&apos;&#125;)子窗口：var img_url;parent.$(&quot;input[name=&apos;img&apos;]&quot;).val(img_url);parent.$(&apos;#img&apos;).attr(&apos;src&apos;, img_url);parent.layer.closeAll(); jQuery获取父元素节点、子元素节点及兄弟元素节点的方法123456789&lt;ul class=&quot;par&quot;&gt; &lt;li id=&quot;firstli&quot;&gt; &lt;h3 class=&quot;title&quot;&gt;one&lt;/h3&gt; &lt;ul class=&quot;par&quot;&gt; &lt;li id=&quot;one&quot;&gt;one_first&lt;/li&gt; &lt;li&gt;two_first&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; jquery父节点的获取使用parent()获取父节点123$(&quot;#one&quot;).parent().parent(); // 获取 id为firstli的li标签节点$(&quot;#one&quot;).parent().parent(&apos;.par&apos;); // 获取最上面 class为par的ul节点$(&quot;#one&quot;).parent(&apos;.par&apos;); // 获取 id为one的上一级class为par的ul节点 使用parents()和closest()获取父节点 closest从当前元素开始匹配寻找，逐级向上寻找直到找到匹配的元素后就停止了，返回0或者1个元素 parents从父元素开始匹配寻找，一直向上查找直到找到根元素，将所有元素放到另外一个集合中，返回0、1或者更多元素12$(&quot;#one&quot;).parnets(&apos;.par&apos;); // 找出所有class为par的父节点/父父节点$(&quot;one&quot;).closest(&apos;.par&apos;); // 获取最近一层的父级class为par的ul节点 jquery兄弟节点的获取parent父节点再find子节点1$(&apos;.title&apos;).parent().find(&apos;ul&apos;); // 找到class为title的兄弟节点ul，即class为par的ul sibingls()获取兄弟节点1$(&apos;.title&apos;).sibings(&apos;ul&apos;); // 找到class为title的兄弟节点ul，即class为par的ul jquery子节点的获取:first方式1$(&apos;.par:first-child&apos;); // 获取id为firstli的li节点 选择器获取1$(&apos;#firstli h3.title&apos;); // 获取class为title的h3节点 find()函数1$(&apos;#firstli&apos;).find(&apos;h3&apos;); // 获取class为title的h3节点 children()函数1$(&apos;#firstli&apos;).children(&apos;h3.title&apos;); // 获取class为title的h3节点]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery获取表单值及属性内容]]></title>
    <url>%2F2018%2F04%2F21%2Fjs_1%2F</url>
    <content type="text"><![CDATA[平时前端在处理表单数据的时候，总是需要通过表单属性或者值来进行一些用户看不到的处理。比如：联动选项的处理、数据的验证过滤等。本节针对不同的表单内容进行了不同的获取方式。 获取当前表单元素的值1234567&lt;input type=&quot;text&quot; name=&quot;name&quot; onblur=&quot;getValue(this)&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; function getValue(obj)&#123; // 获取值 $(obj).val(); &#125;&lt;/script&gt; 获取表单元素值及属性内容123456789101112131415161718192021&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;select name=&quot;sex&quot; data-type=&quot;sex&quot; field=&quot;sex&quot;&gt; &lt;option value=&quot;man&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt;&lt;/select&gt;&lt;script type=&quot;text/javascript&quot;&gt; function do_submit(obj)&#123; // 获取值 var name = $(&quot;input[name=&apos;name&apos;]&quot;).val(); var sex_value = $(&quot;select[name=&apos;sex&apos;]&quot;).val(); // 获取特定文本值的数据 $(&apos;select[name=&quot;data[select]&quot;] [value=&quot;man&quot;]&apos;).val(); // 获取文本值 var sex_text = $(&quot;select[name=&apos;sex&apos;]&quot;).find(&apos;option:selected&apos;).text(); // 获取data-type属性值 var sex_type = $(&quot;select[name=&apos;sex&apos;]&quot;).data(&apos;type&apos;); var sex_type = $(&quot;select[name=&apos;sex&apos;]&quot;).attr(&apos;data-type&apos;); // 获取field属性值 var sex_field = $(&quot;select[name=&apos;sex&apos;]&quot;).attr(&apos;field&apos;); &#125;&lt;/script&gt; 获取多个多行文本框内容值123456789&lt;textarea name=&quot;formula[]&quot; class=&quot;text&quot;&gt;&lt;/textarea&gt;&lt;textarea name=&quot;formula[]&quot; class=&quot;text&quot;&gt;&lt;/textarea&gt;&lt;textarea name=&quot;formula[]&quot; class=&quot;text&quot;&gt;&lt;/textarea&gt;&lt;script type=&quot;text/javascript&quot;&gt; var formula = new Array(); $(&quot;.text,textarea&quot;).each(function(e)&#123; formula.push($(this).val()); &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换电脑后的博客续写]]></title>
    <url>%2F2018%2F04%2F04%2Fchange_do_hexo%2F</url>
    <content type="text"><![CDATA[当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 使用git clone git@github.com:zhipenwang/zhipenwang.github.io.git拷贝仓库（默认分支为master）； 在本地新拷贝的http://zhipenwang.github.io文件夹下通过Git bash依次执行下列指令： 123npm install hexonpm installnpm install hexo-deployer-git （记得，不需要hexo init这条指令）。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 误删分支恢复方法]]></title>
    <url>%2F2018%2F03%2F28%2Fgit_recover_branch%2F</url>
    <content type="text"><![CDATA[在使用git的时候，有时候会因为人为因素导致分支（commit）被删除，可以使用如下步骤进行恢复。 首先使用以下步骤创建一个新分支，修改一些文件后删除，以便进行恢复1、创建分支hexo1git branch hexo 2、查看分支列表123git branch -a * master hexo 3、切换到hexo分支，随便修改一下东西后commit123456git checkout hexoecho &apos;hexo&apos; &gt; test.txtgit add .git commit -m &apos;add test.txt&apos; 4、删除分支1git branch -D hexo 5、查看分支列表，hexo分支已经不存在12git branch -a * master 恢复步骤如下1、使用git log -g 找回之前提交的commit1234567commit 3eac14d05bc1264cda54a7c21f04c3892f32406aReflog: HEAD@&#123;1&#125; (fdipzone &lt;fdipzone@sina.com&gt;)Reflog message: commit: add test.txtAuthor: fdipzone &lt;fdipzone@sina.com&gt;Date: Sun Jan 31 22:26:33 2016 +0800 add test.txt 2、使用 git branch recover_branch[新分支] commit_id 命令，用这个commit创建一个分支12345git branch recover_branch_hexo 3eac14d05bc1264cda54a7c21f04c3892f32406agit branch -a* master recover_branch_hexo 这个时候，可以看到 recover_branch_hexo分支已经创建了。3、切换到recover_branch_hexo分支，检查文件是否存在12git checkout recover_branch_hexols -lt 这样就可以恢复误删除的分支了。]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 配置ssh密钥]]></title>
    <url>%2F2018%2F03%2F27%2Fssh_key%2F</url>
    <content type="text"><![CDATA[在github帐号注册好之后，将项目clone到本地，加入git bash命令。1、输入cd ~/.ssh 回车，查看是否有ssh key密钥，有了就备份 2、创建ssh key，输入下面命令回车，之后会让你输入github的账号密码，如图12345ssh-keygen -t rsa -C &quot;youremail@youremail.com&quot;Creates a new ssh key using the provided email # Generating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa): 直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)：1Enter same passphrase again: [Type passphrase again] 完了之后，大概是这样：12Your public key has been saved in /home/you/.ssh/id_rsa.pub.The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com 3、找到本地id_rsa.pub文件，复制里面的内容，这就是ssh密钥，可以通过pwd命令来查看当前文件位置 4、登录github，在个人中心的setting中，找到 SSH and GPG keys 点击 new ssh key，将复制的ssh密钥粘贴进 “key”文本框，title随便输入即可。点击add key。添加ssh密钥到远程仓库完成。5、验证ssh是否可用1ssh -T git@github.com 返回如下表示正常可用。1Hi xxx! You&apos;ve successfully authenticated, but GitHub does not # provide shell access. 6、此时查看你的远程分支地址是否是ssh协议的123git remote -vorigin https://github.com/zhipenwang/zhipenwang.git (fetch)origin https://github.com/zhipenwang/zhipenwang.git (push) 如果是https协议，修改为ssh协议：1git remote set-url origin git@github.com:zhipenwang/zhipenwang.git 这个时候就可以进行push了。]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始算法]]></title>
    <url>%2F2018%2F02%2F13%2Falgorithm%2F</url>
    <content type="text"><![CDATA[算法：程序的灵魂 算法：algorithm 算法五大特征： 1、有穷性：保证执行有限步骤后结束 2、确切性：每一步骤都有确切的意义 3、输入：每个算法都有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身定除了初始条件 4、输出：每个算法都有一个或多个输出，显示对输入数据加工后的结果。没有输出的算法是毫无意义的 5、可行性：在原则上算法能够精确地运行，进行优先次运算后即可完成的一种运算。 算法的逻辑、流程。计算机中的算法，分为两大类：数值运算算法（求解数值）、非数值运算算法（事务管理领域）。算法是计算机处理信息的本质，因为计算机程序本质上是一个算法，告诉计算机确切的步骤来执行一个指定的任务。 著名计算机科学家沃思公式：数据结构+算法=程序。 一个程序应当采用结构化程序设计方法进行程序设计，并且用某一种计算机语言来表示，因此，下面的公式更加贴切： 程序=算法+数据结构+程序设计方法+语言和环境 流程图来表示算法： 流程图的结构：顺序结构、选择结构、循环结构 N-S图 N-S流程图：代表计算机的算法。由一些特定意义的图像、流程线及简要的文字说明构成，能够清晰明确的表示程序的运行过程。（整个程序写在一个大框图内，由若干个小的基础框图构成，简称N-S图） 计算机语言的算法表示计算机语言表示算法的时候，必须严格遵循使用语言的语法规则。 学好算法的秘诀1、学的深入，基础扎实2、恒心、演练、举一反三3、语言之争的时代更要学会坚持]]></content>
      <categories>
        <category>算法与结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer构建PHP框架——构建路由]]></title>
    <url>%2F2017%2F04%2F21%2Fcomposer-3%2F</url>
    <content type="text"><![CDATA[路由选择安装本节开始构建路由，先去 GitHub 搜一下：点此查看搜索结果 推荐 https://github.com/NoahBuscher/Macaw，对应的 Composer 包为 noahbuscher/macaw 。 下面开始安装它，更改 composer.json：12345&#123; &quot;require&quot;:&#123; &quot;noahbuscher/macaw&quot;: &quot;dev-master&quot; &#125;&#125; 运行 composer update，成功之后将得到以下目录： 至此，Macaw安装成功！ 站点入口文件与环境在项目目录下新建public 文件夹，这个文件夹将是用户唯一可见的部分。在文件夹下新建 index.php 文件：1234567&lt;?php// Autoload 自动载入require &apos;../vendor/autoload.php&apos;;// 路由配置require &apos;../config/routes.php&apos;; 上面一行表示引入 Composer 的自动载入功能，下面一行表示载入路由配置文件。然后继续在项目目录下新建config文件夹，在config文件夹内新建 routs.php 文件，内容如下：12345678910111213&lt;?phpuse NoahBuscher\Macaw\Macaw;Macaw::get(&apos;fuck&apos;, function() &#123; echo &quot;成功！&quot;;&#125;);Macaw::get(&apos;(:all)&apos;, function($fu) &#123; echo &apos;未匹配到路由&lt;br&gt;&apos;.$fu;&#125;);Macaw::dispatch(); 然后访问你的地址即可：http://127.0.0.66/index.php/fuck 注意：如果要配置域名地址进行映射要指向 public/index.php 文件]]></content>
      <categories>
        <category>composer使用</category>
      </categories>
      <tags>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer安装与使用]]></title>
    <url>%2F2017%2F04%2F21%2Fcomposer-1%2F</url>
    <content type="text"><![CDATA[安装1、点击下载：composer 2、下载好之后双击直接安装，Next即可：3、然后选择php.exe文件： 接下来就一直next到安装完成即可。 使用 [info]使用composer安装ThinkPHP5 通过composer中国镜像进行初步了解 ##开始命令行操作 1、中国镜像下载参考tp5看云文档 由于国外网站访问很慢，国内提供了很好的镜像，所以使用国内镜像：1Composer config -g repo.packagist composer https://packagist.phpcomposer.com 2、下载tp5框架进入站点根目录www操作命令行：1composer create-project topthink/think tp5 --prefer-dist 其中tp5可写填写任何你愿意的名称 框架安装完成耐心等待几分钟的安装过程，安装完成之后本地已经生成了tp5的新框架内容 composer主要的功能：安装扩展包composer的最主要的功能：dependency manager for PHP进入项目目录tp5，执行命令：1composer require riverslei/payment 下载riverslei/payment 集成支付宝、微信支付等流行的支付接口到项目中：Composer.json中新增了这一句： 项目目录中也已经安装好了扩展包：]]></content>
      <categories>
        <category>composer使用</category>
      </categories>
      <tags>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[composer构建PHP框架——初始化]]></title>
    <url>%2F2017%2F04%2F21%2Fcomposer-2%2F</url>
    <content type="text"><![CDATA[“一个时代结束了，另一个时代开始了。”Framework Interoperability Group（框架可互用性小组），简称 FIG，成立于 2009 年。FIG 最初由几位知名 PHP 框架开发者发起，在吸纳了许多优秀的大脑和强健的体魄后，提出了 PSR-0 到 PSR-4 五套 PHP 非官方规范： 123456789* PSR-0 (Autoloading Standard) 自动加载标准* PSR-1 (Basic Coding Standard) 基础编码标准* PSR-2 (Coding Style Guide) 编码风格向导* PSR-3 (Logger Interface) 日志接口* PSR-4 (Improved Autoloading) 自动加载优化标准 创建composer.json在网站根目录下创建新文件夹 my-framework （My First Framework based on Composer），然后在此文件夹内创建 composer.json 文件12345&#123; &quot;require&quot;:&#123; &#125;&#125; 初始化composer打开命令行cmd，进入刚刚新建的目录 my_framework，执行命令1composer update 执行成功后生成了扩展包vendor 此时目录为： 到此，composer初始化完成！]]></content>
      <categories>
        <category>composer使用</category>
      </categories>
      <tags>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题内接入网页在线联系功能]]></title>
    <url>%2F2017%2F04%2F20%2Fconnect%2F</url>
    <content type="text"><![CDATA[Hexo博客如何添加在线联系功能呢,发现了一个不错的网站可以提供在线联系的服务，当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。 注册首先在(DaoVoice)[http://www.daovoice.io/]注册个账号。登录上去之后进行配置，配置方法如下:首先到DaoVoice上注册一个账号,注册完成后会得到一个app_id，获取appid的步骤如下图所示: 以next主题为例,打开/themes/next/layout/_partials/head.swig文件添加如下代码：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 接着打开主题配置文件_config.yml，添加如下代码：123# Online contact daovoice: truedaovoice_app_id: 这里输入前面获取的app_id 需要注意的是,next主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置:最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，就可以实时收发消息，有新的消息也会通过微信通知，设置页面如下:]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加字数统计、阅读时长、浏览次数]]></title>
    <url>%2F2017%2F04%2F19%2Fblog_view%2F</url>
    <content type="text"><![CDATA[统计插件配置NexT 主题默认已经集成了文章【浏览次数】、【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要修改主题配置文件 _config.yml 即可。如下所示：配置浏览次数123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访问人数 site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 总访问量 site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 浏览 page_pv_footer: 次 配置字数统计、阅读时长，wordcount与min2read统计功能12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: false # 网站 字数统计 separated_meta: true 预览的时候如果出现字数统计和阅读时长失效的情况，一般是因为没有安装 hexo-wordcount 插件，查看 Hexo 插件：12345hexo --debug``### 安装如果没有安装 hexo-wordcount 插件，先安装该插件： npm i –save hexo-wordcount1*** Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下：*** npm install hexo-wordcount@2 –save```安装完成后，重新执行启动服务预览就可以了。 显示文字打开post.swig文件，路径如下：xxx_blog/themes/next/layout/_macro/post.swig]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题内给每篇文章后添加结束标语]]></title>
    <url>%2F2017%2F04%2F18%2Fhexo_next_end%2F</url>
    <content type="text"><![CDATA[给文章后面添加结束标语 新建文件在\themes\next\layout\_macro中新建passage-end-tag.swig文件，添加代码至该文件中：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:22px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 修改post.swig打开\themes\next\layout_macro\post.swig文件，在post-body后，post-footer前，添加下面内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改_config打开主题配置文件（_config.yml),在末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 至此，就完成了关于添加文章结束标语的功能，具体的效果，此刻，想必你也看到了，就在下边。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题添加点击爱心效果]]></title>
    <url>%2F2017%2F04%2F17%2Fclickheart%2F</url>
    <content type="text"><![CDATA[给NexT主题内添加页面点击出现爱心的效果 创建js文件在/themes/next/source/js/src下新建文件clicklove.js，接着把该链接下的代码拷贝粘贴到clicklove.js文件中。代码如下：1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 修改_layout.swig在\themes\next\layout\_layout.swig文件末尾添加：12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo发布文章]]></title>
    <url>%2F2017%2F03%2F19%2Fhexo_new_blog%2F</url>
    <content type="text"><![CDATA[在部署和搭建好hexo博客后，怎么写好一篇博客并发布到在线地址呢？ 1、找到你本地的博客地址，在source/_posts目录下新建新文件，后缀为md，写一篇markdown文章2、打开git bash命令端本地预览：1hexo server 提交到git仓库，同步到在线博客123hexo cleanhexo generatehexo deploy 然后就可以在你的博客看到更新的文章了。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建个人博客]]></title>
    <url>%2F2017%2F03%2F18%2Fcreate-blog%2F</url>
    <content type="text"><![CDATA[各位有兴趣搭建博客或者正在搭建博客却遇到问题的朋友们，不妨抽空来围观一下我搭建的过程中遇到的坑和填的土。。 声明一点，以下所有步骤都是基于Windows系统的搭建，由于本人没有真正在其他系统上搭建过，就不画蛇添足了，所以其他系统的小心不要入错入坑咯 下面先说一下基本思路（给大家一个清晰的搭建过程）： 1、在Windows系统下搭建运行hexo环境的前提是先搭建nodejs跟git2、搭建好nodejs跟git后就可以在系统中搭建hexo环境3、申请github.com帐号，创建自己的repository（仓库）——注意仓库名必须是：yourusername.github.io，具体原因及内容后面细讲、4、本地hexo环境部署到github上 5、yourusername.github.io查看自己的博客，成功！ 第一步：搭建nodejs环境参考菜鸟教程的nodejs，很是详细：nodejs-菜鸟教程 大家可以去nodejs官网下载，记得要下载跟自己Windows系统一致的版本。（64bit的下载window-install的64-bit；同理：32bit的下载32-bit的）。下载之后双击安装，选择自己要安装的路径地址，一直next到finish就可以了安装后检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入”cmd” =&gt; 输入命令”path”，输出结果中有nodejs的环境变量说明安装成功。（如下我的环境变量已经有nodejs了）1234PATH=C:\oraclexe\app\oracle\product\10.2.0\server\bin;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;c:\python32\python;C:\MinGW\bin;C:\Program Files\GTK2-Runtime\lib;C:\Program Files\MySQL\MySQL Server 5.5\bin;C:\Program Files\nodejs\; 然后可以检查一下Node.js版本，直接命令行输入 node –versionok，nodejs环境到此完成。 第二步：搭建GIT环境同样，大家可以参考百度经验 下载地址可以前往git官网进行下载，同样下载跟自己系统位数一致的版本下载之后双击选择自己要安装的路径地址一键next安装就好了安装好之后在任意位置右键都可以看到关于git的一些菜单选项：ok，至此git安装完成。 第三步：搭建hexo环境在E盘下建立hexo文件夹（或者你选择的任何路径）在nodejs和git环境都搭建完成后，在刚刚建立好的hexo文件夹中点击鼠标右键，选择git bash，输入以下命令安装hexo1npm install -g hexo 接下来是比较重要的步骤，都是在git bash命令行操作，要认真看清楚： 1、初始化你的博客1hexo init 执行后hexo会在你的站点目录下生成网站所需的文件 2、安装node_modules：1npm install 在此目录中生成node_modules 3、本地浏览器查看：1hexo server (此命令也可以简写为 hexo s) 这时候会出现如下信息：[info] Hexo is running at http://localhost:4000/.Press Ctrl+C to stop. 这个时候在你的浏览器输入http://localhost:4000/你就可以看到本地的博客搭建成功。这个时候可以轻松一下，随便浏览一下自己的博客熟悉一下 第四步：本地hexo部署到github上1、首先要有github帐号，可以前往github官网注册一个自己的github帐号，登录成功后，点击右上角的+号新建一个仓库注意，仓库名必须跟自己的username一致，格式是username.github.io]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的意义]]></title>
    <url>%2F2017%2F03%2F17%2Fblog%2F</url>
    <content type="text"><![CDATA[文中内容仅是个人观点，不喜随便喷，如有雷同，欢迎交流 为什么有开博客的想法呢？作为一名后端攻城狮，在各种“撸码”的过程中经常会碰到一些萝卜坑，当然及时植入了萝卜。开始填的时候也不以为常，管他下次会不会被挖再露出坑，慢慢学习的过程中遇到了更多的坑，觉得有点烧闹了，开始各种方式去学着记录，D、E、F盘塞了各种记录文本，慢慢发现这种方式查阅起来很是麻烦，而且最关键的是，有一次打开我记录了几千行的笔记，结果发现乱码了（原因是一直用gbk去写的，某一次脑短路用了默认utf格式的编辑器打开，整篇文档都乱码，又手贱的去直接在编辑器中点错了其他格式还保存，果然是自作孽不可活），后来各种软件编辑器尝试，越来越不认识其字符了，不过对咱来说，没法补救的东西失去了那就从头再来呗。这个时候开始打算换一种方式来记录一些自己遇到的坑和一些有价值的内容，同时也可以在一个平台上跟其他有深度的人沟通学习成长，所以打算在大平台去搭建一个属于个人的主页。 其中， 新浪博客、QQ空间、CSDN等“个人主页”都流行很久了，所以有越来越多的人开始考虑搭建一个真正属于自己的“个人主页”，个人博客建站也越来越流行。那么搭建个人博客的目的无非是以下几点： 作为一个展示个性的平台搭建一个展示个人观点、爱好、经历的良好平台，跟那些流行的新浪博客和QQ空间不一样，个人博客可以很灵活自由的去设计ownerstyle的网站。 作为一个知识积累的海洋不管是从事文学、管理、IT开发，都可以通过这个平台去记录一些有价值对自己有影响的内容，积累成一个属于自己知识的海洋 作为一个交流分享的平台不仅仅把自己的知识积累下来，更大程度的去分享，了解别人的一些不同看法，沟通完善一些自我的缺陷，学习别人更广的知识 作为一个攻城狮，要时刻去接触互联网新的思想，去真正参与到互联网中，既然决定了写博客，那么自己动手去搭建一个专属的博客，然后一步步去推广，不仅仅会带来前进的动力，其实也会慢慢去接触学习到什么才是真正的SEO（搜索引擎–百度搜索排行其实很大程度就是靠这个），也会去认识到网络推广。对目前的我而言，那就是希望坚持下去，作为一个自我价值的体现，在未来的工作或者社交中能够以这个平台去让别人了解自己，成为自我的一个标识。]]></content>
      <categories>
        <category>博客思维</category>
      </categories>
      <tags>
        <tag>Article</tag>
      </tags>
  </entry>
</search>
