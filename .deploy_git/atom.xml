<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王志鹏</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhipenwang.github.io/"/>
  <updated>2018-06-10T09:33:36.754Z</updated>
  <id>https://zhipenwang.github.io/</id>
  
  <author>
    <name>王志鹏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux下关于服务端口的配置</title>
    <link href="https://zhipenwang.github.io/2018/06/10/server_port/"/>
    <id>https://zhipenwang.github.io/2018/06/10/server_port/</id>
    <published>2018-06-10T09:29:26.470Z</published>
    <updated>2018-06-10T09:33:36.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="端口服务"><a href="#端口服务" class="headerlink" title="端口服务"></a>端口服务</h3><blockquote><p>查看端口使用情况</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">netstat命令各个参数说明如下:</div><div class="line">    -t : 指明显示TCP端口</div><div class="line">    -u : 指明显示UDP端口</div><div class="line">    -l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)</div><div class="line">    -p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。</div><div class="line">    -n : 不进行DNS轮询，显示IP(可以加速操作)</div><div class="line">netstat -ntlp   //查看当前所有tcp端口·</div><div class="line">netstat -ntulp |grep 80   //查看所有80端口使用情况·</div><div class="line">netstat -an | grep 3306   //查看所有3306端口使用情况·</div></pre></td></tr></table></figure><h3 id="端口映射配置"><a href="#端口映射配置" class="headerlink" title="端口映射配置"></a>端口映射配置</h3><blockquote><p>需求：<br>PC_A是 eth0: 172.18.10.212  内网；eth1: 219.239.xx.xx  外网</p><p>PC_B是 172.18.10.205  内网</p><p>A的8080端口映射到B的80端口</p></blockquote><h4 id="1-首先应该做的是"><a href="#1-首先应该做的是" class="headerlink" title="1. 首先应该做的是"></a>1. 首先应该做的是</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/etc/sysctl.conf配置文件:</div><div class="line">    net.ipv4.ip_forward = 1 默认是0.</div><div class="line">这样允许iptalbes FORWARD。</div></pre></td></tr></table></figure><h4 id="2-在-etc-rc-d-init-d目录下有iptables-文件，使用格式如下"><a href="#2-在-etc-rc-d-init-d目录下有iptables-文件，使用格式如下" class="headerlink" title="2. 在/etc/rc.d/init.d目录下有iptables 文件，使用格式如下"></a>2. 在/etc/rc.d/init.d目录下有iptables 文件，使用格式如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Usage: ./iptables &#123;start|stop|restart|condrestart|status|panic|save&#125;</div><div class="line">    相当与service iptables &#123;....&#125;</div><div class="line">    把iptables 服务停止，清除以前的规则，存盘</div><div class="line">    </div><div class="line">到/etc/rc.d/init.d目录下，运行</div><div class="line">    ./iptables stop</div><div class="line">    iptalbes -F</div><div class="line">    iptalbes -X</div><div class="line">    iptalbes -Z</div><div class="line">    ./iptables save</div></pre></td></tr></table></figure><h4 id="3-重新配置规则"><a href="#3-重新配置规则" class="headerlink" title="3. 重新配置规则"></a>3. 重新配置规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A PREROUTING -d 219.239.xx.xx -p tcp --dport 8080 -j DNAT --to-destination 172.18.10.205:80</div><div class="line"></div><div class="line">iptables -t nat -A POSTROUTING -d 172.18.10.205 -p tcp --dport 80 -j SNAT --to 172.18.10.212</div><div class="line"></div><div class="line">iptables -A FORWARD -o eth0 -d 172.18.10.205 -p tcp --dport 80 -j ACCEPT</div><div class="line"></div><div class="line">iptables -A FORWARD -i eth0 -s 172.18.10.205 -p tcp --sport 80 -j ACCEPT</div><div class="line"></div><div class="line">DNAT SNAT 的请参考帮助，这里不再陈述。</div></pre></td></tr></table></figure><h4 id="4-新的规则存盘"><a href="#4-新的规则存盘" class="headerlink" title="4. 新的规则存盘"></a>4. 新的规则存盘</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> ./iptables save</div><div class="line"></div><div class="line">规则存盘后在/etc/sysconfig/iptables这个文件里面，若你对这个文件很熟悉</div><div class="line">直接修改这里的内容也等于命令行方式输入规则。</div></pre></td></tr></table></figure><h4 id="5-启动iptables-服务"><a href="#5-启动iptables-服务" class="headerlink" title="5. 启动iptables 服务"></a>5. 启动iptables 服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">./iptables start</div><div class="line">在/proc/net/ip_conntrack文件里有包的流向，如下面</div><div class="line"></div><div class="line">   tcp 6 53 TIME_WAIT src=221.122.59.2 dst=219.239.xx.xx sport=7958 dport=8080 packets=9 bytes=1753</div><div class="line">   </div><div class="line">   src=172.18.10.205 dst=172.18.10.212 sport=80 dport=7958 packets=9 bytes=5777 [ASSURED] use=1</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;端口服务&quot;&gt;&lt;a href=&quot;#端口服务&quot; class=&quot;headerlink&quot; title=&quot;端口服务&quot;&gt;&lt;/a&gt;端口服务&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;查看端口使用情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="服务器" scheme="https://zhipenwang.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="运维" scheme="https://zhipenwang.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>jQuery的三种bind/One/Live/On事件绑定使用方法</title>
    <link href="https://zhipenwang.github.io/2018/05/20/js_5/"/>
    <id>https://zhipenwang.github.io/2018/05/20/js_5/</id>
    <published>2018-05-20T12:36:52.303Z</published>
    <updated>2018-05-20T12:50:44.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="on-events-selector-data-fn"><a href="#on-events-selector-data-fn" class="headerlink" title="on(events,[selector],[data],fn)"></a>on(events,[selector],[data],fn)</h3><blockquote><p>events:一个或多个用空格分隔的事件类型和可选的命名空间，如”click”或”keydown.myPlugin” 。<br>selector:一个选择器字符串用于过滤器的触发事件的选择器元素的后代。如果选择器为null或省略，当它到达选定的元素，事件总是触发。<br>data:当一个事件被触发时要传递event.data给事件处理函数。<br>fn:该事件被触发时执行的函数。 false 值也可以做一个函数的简写，返回false</p></blockquote><h4 id="替换bind"><a href="#替换bind" class="headerlink" title="替换bind()"></a>替换bind()</h4><blockquote><p>当第二个参数’selector’为null时，on()和bind()其实在用法上基本上没有任何区别了，所以我们可以认为on()只是比bind()多了一个可选的’selector’参数，所以on()可以非常方便的换掉bind()</p></blockquote><h4 id="替换live"><a href="#替换live" class="headerlink" title="替换live()"></a>替换live()</h4><blockquote><p>在1.4之前相信大家非常喜欢使用live(),因为它可以把事件绑定到当前以及以后添加的元素上面，当然在1.4之后delegate()也可以做类似的事情了。live()的原理很简单，它是通过document进行事件委派的，因此我们也可以使用on()通过将事件绑定到document来达到live()一样的效果。</p></blockquote><h4 id="live-写法"><a href="#live-写法" class="headerlink" title="live()写法"></a>live()写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(&apos;#list li&apos;).live(&apos;click&apos;, &apos;#list li&apos;, </div><div class="line">function() &#123;</div><div class="line">//function code here.</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="on-写法"><a href="#on-写法" class="headerlink" title="on()写法"></a>on()写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(document).on(&apos;click&apos;, &apos;#list li&apos;, </div><div class="line">function() &#123;</div><div class="line"> //function code </div><div class="line">here.</div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><p>这里的关键就是第二个参数’selector’在起作用了。它是一个过滤器的作用，只有被选中元素的后代元素才会触发事件。</p></blockquote><h4 id="替换delegate"><a href="#替换delegate" class="headerlink" title="替换delegate()"></a>替换delegate()</h4><blockquote><p>delegate()是1.4引入的，目的是通过祖先元素来代理委派后代元素的事件绑定问题，某种程度上和live()优点相似。只不过live()是通过document元素委派，而delegate则可以是任意的祖先节点。使用on()实现代理的写法和delegate()基本一致。</p></blockquote><h4 id="delegate-的写法"><a href="#delegate-的写法" class="headerlink" title="delegate()的写法"></a>delegate()的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(&apos;#list&apos;).delegate(&apos;li&apos;, &apos;click&apos;, </div><div class="line">function() &#123;</div><div class="line"> //function code here.</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="on-写法-1"><a href="#on-写法-1" class="headerlink" title="on()写法"></a>on()写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(&apos;#list&apos;).on(&apos;click&apos;, &apos;li&apos;, function() </div><div class="line">&#123;</div><div class="line"> //function code here.</div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><p>貌似第一个和第二个参数的顺序颠倒了一下，别的基本一样。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>jQuery推出on()的目的有2个，一是为了统一接口，二是为了提高性能，所以从现在开始用on()替换bind(),<br>live(),<br>delegate吧。尤其是不要再用live()了，因为它已经处于不推荐使用列表了，随时会被干掉。如果只绑定一次事件，那接着用one()吧，这个没有变化。<br>jQuery是 一款优秀的JavaScript框架,在旧版里主要用bind()方法，在新版里又多了两种One(),Live()<br>下面介绍这几种方法的使用：</p></blockquote><h4 id="1-bind-Unbind"><a href="#1-bind-Unbind" class="headerlink" title="1. bind/Unbind"></a>1. bind/Unbind</h4><blockquote><p>在jquery的事件模型中，有两个基本的事件绑 定函数，bind与unbind，这两个函数的含义就是匹配页面元素进行相关事件的处理。比如我们在JS中经常使用到的 onfocus，onblur，onmouseover，onmousedown等事件都可以作为bind的参数进行传递。<br>$(“#id”).bind(‘click’,function(){alert(‘tt!’)});<br>其中bind的第一个参数代表的含义是：事件类型(注意不需要加on)，function中的代码就是你要执行的逻辑 代码<br>多个事件绑定：bind还允许你绑定多个事件，事件名字之间用空格隔开，例如：<br>$(‘a’).bind(‘click mouseover’,function(){<br>在最新的jquery1.4版本中，对bind方法进行了改进，你可以在bind方法传入一个类JSON对象来一次绑定多 个事件处理函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$(&apos;a&apos;).bind(&#123;</div><div class="line">click:function()&#123;</div><div class="line">alert(&apos;a&apos;);</div><div class="line">&#125;,</div><div class="line">mouseover:function()&#123;</div><div class="line">alert(&apos;a again!&apos;)</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>在function函数中，你还可以通过传递一个javaScript对 象给function方法，这个事件对象通常是可以省略的。<br>bind中还有一个参数data， 该参数一般情况下很少使用，通常为了解决在同一个方法中处理同一个变量时有很好的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var productname=&quot;Sports Shoes&quot;;</div><div class="line">$(&apos;#Area&apos;).bind(&apos;click&apos;,function()&#123;</div><div class="line">alert(productname);</div><div class="line">&#125;);</div><div class="line">productname=&quot;necklace&quot;,</div><div class="line">$(&apos;#Area&apos;).bind(&apos;click&apos;,function()&#123;</div><div class="line">alert(productname);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>由于变量productname被重新赋值，所以输出的消息都是”necklace”,这里不了解可以去查阅下关于JavaScript的变量作用域,要 解决这个问题就必须使用到data参数，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var productname=&quot;Sports Shoes&quot;;</div><div class="line">$(&apos;#Area&apos;).bind(&apos;click&apos;,&#123;pn:productname&#125;,function()&#123;</div><div class="line">alert(event.data.pn);</div><div class="line">&#125;);</div><div class="line">productname=&quot;necklace&quot;,</div><div class="line">$(&apos;#Area&apos;).bind(&apos;click&apos;,&#123;pn:productname&#125;,function()&#123;</div><div class="line">alert(event.data.pn);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p></blockquote><h4 id="2-One"><a href="#2-One" class="headerlink" title="2. One"></a>2. One</h4><p>为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。该方法与bind方法的参数一样，与bind方法的区别就是只对匹配元素的事 件处理执行一次，执行完之后，以后再也不会执行,当然重新发起web请求时它又会执行一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;a&apos;).one(&apos;click&apos;,function()&#123;</div><div class="line">alert(&apos;a&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><blockquote><p>单击页面上的a元素后，弹出消息，除非用户发起第二次请求，否则再次点击a元素不会弹出消息对话框。</p></blockquote><h4 id="3-live"><a href="#3-live" class="headerlink" title="3. live"></a>3. live</h4><p>该方法主要是能处理动态添加的元素，给那些后添加的元素也一样绑定事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;a&apos;).live(&apos;click,function()&#123;</div><div class="line">alert(&apos;show message!&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><blockquote><p>然后如果我添加一个元素，<br>$(‘body’).appnend(‘Another Element’);<br>那么该元素也会被触发事件处理函数alert。<br>另外，jQuery还提供了一些绑定这些标准事件类型的简单方式，比如.click()用于简化.bind(‘click’)。<br>一共有以下这些事件名称：blur, focus, focusin, focusout, load, resize, scroll, unload, click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout, mouseenter, mouseleave, change, select, submit, keydown, keypress, keyup, error 等。<br>下面看下jQuery中绑定事件bind() on() live() one()的异同<br>jQuery中绑定事件的四种方法，他们可以同时绑定一个或多个事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bind()----------版本号小于3.0（在Jquery3.0中已经移除，相应unbind()也移除）</div><div class="line">live()----------版本号小于1.7（在Jquery1.7中已经移除，相应die()也移除）</div><div class="line">delegate()------版本号小于1.7（在Jquery1.7中已经移除）</div><div class="line">on()------------版本号大于1.7（在Jquery1.7中添加，相应off()也添加）</div></pre></td></tr></table></figure></p><p>A：bind()事件的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;title&gt;绑定事件&lt;/title&gt;</div><div class="line"> &lt;script src=&quot;js/jQuery1.11.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</div><div class="line"> &lt;script&gt;</div><div class="line">  $(function () &#123;</div><div class="line">   $(&quot;p&quot;).bind(&#123;</div><div class="line">    &quot;mouseover&quot;: function () &#123;</div><div class="line">     $(&quot;p&quot;).css(&quot;background-color&quot;, &quot;red&quot;);</div><div class="line">    &#125;,</div><div class="line">    &quot;mouseout&quot;: function () &#123;</div><div class="line">     $(&quot;p&quot;).css(&quot;background-color&quot;, &quot;&quot;);</div><div class="line">    &#125;</div><div class="line">   &#125;);</div><div class="line">  &#125;);</div><div class="line"> &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"> &lt;p&gt;what are you doing?&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p><p>第一个最大的区别就是：bind()的事件绑定是只对当前页面选中的元素有效。如果你想对动态创建的元素bind()事件，是没有办法达到效果的。<br>在后面的动态生成DOM元素绑定事件就要使用on();</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;on-events-selector-data-fn&quot;&gt;&lt;a href=&quot;#on-events-selector-data-fn&quot; class=&quot;headerlink&quot; title=&quot;on(events,[selector],[data],fn)&quot;&gt;&lt;/a&gt;on(
      
    
    </summary>
    
      <category term="jQuery" scheme="https://zhipenwang.github.io/categories/jQuery/"/>
    
    
      <category term="Web前端" scheme="https://zhipenwang.github.io/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>js 比较几种遍历数组及对象的方式</title>
    <link href="https://zhipenwang.github.io/2018/05/13/js_4/"/>
    <id>https://zhipenwang.github.io/2018/05/13/js_4/</id>
    <published>2018-05-13T03:26:43.661Z</published>
    <updated>2018-05-13T03:42:20.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。<br>一般我们会采用下几种方式来进行数组的遍历：</p></blockquote><h3 id="方式1：for-in-循环"><a href="#方式1：for-in-循环" class="headerlink" title="方式1：for in 循环"></a>方式1：for in 循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5];</div><div class="line">var obj = &#123; a : 1, b : 2, c : 3 &#125;;</div><div class="line">for( var item in arr|obj )&#123;</div><div class="line">        fn(item)&#123;</div><div class="line">                // do sth with arr[item];</div><div class="line">                //do sth wtih obj[item];</div><div class="line">        &#125;;</div><div class="line">&#125;</div><div class="line">这里的 item：</div><div class="line">        array 的索引值，对应于 arr 的下标值；</div><div class="line">        object 的 key 值，对应于 obj 的 a,b,c；</div></pre></td></tr></table></figure><h3 id="方式2：for-循环"><a href="#方式2：for-循环" class="headerlink" title="方式2：for 循环"></a>方式2：for 循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (var i=0; i&lt;arr.length; i++)&#123;</div><div class="line">        //do sth with arr[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题。<br>在方式1中，for-in 需要分析出array 的每个属性，这个操作性能开销很大。用在 key 已知的数组上是非常不划算的。所以尽量不要用 for-in，除非你不清楚要处理哪些属性，例如 JSON 对象这样的情况。<br>在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 array 里存放的都是 DOM 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低。<br>所以这时候我们就有必要对方式2进行优化。</p></blockquote><h4 id="加速的"><a href="#加速的" class="headerlink" title="加速的"></a>加速的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5];</div><div class="line">var length =arr.length;</div><div class="line">for(var i=0; i&lt;length; i++)&#123;</div><div class="line">　　fn(arr[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>现在只需要读取一次 array 的 length 属性，速度已经加快了。但是还能不能更快呢？<br>事实是，如果循环终止条件不进行比较运算，那么循环的速度还可以更快。</p></blockquote><h4 id="加速且优雅的"><a href="#加速且优雅的" class="headerlink" title="加速且优雅的"></a>加速且优雅的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5];</div><div class="line">var i = arr.length;</div><div class="line">while(i--)&#123;</div><div class="line">        fn(arr[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="方式-3：forEach"><a href="#方式-3：forEach" class="headerlink" title="方式 3：forEach"></a>方式 3：forEach</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5];</div><div class="line">arr.forEach(</div><div class="line">        fn(value,index)&#123;</div><div class="line">                //Do sth with value ;</div><div class="line">        &#125;</div><div class="line">)</div></pre></td></tr></table></figure><blockquote><p>注意：<br>这里的 forEach回调中两个参数分别为 value，index，其位置刚好和 jQuery 的$.each 相反；<br>forEach 无法遍历对象；<br>IE不支持该方法；Firefox 和 chrome 支持；<br>forEach 无法使用 break，continue 跳出循环，且使用 return 是跳过本次循环；<br>可以添加第二个参数，为一个数组，回调中的 this 会指向这个数组，若没有添加，则是指向 window；</p></blockquote><p>关于跳出循环的几种方式：</p><ol><li>return ==》结束循环并中断函数执行；</li><li>break ==》结束循环函数继续执行；</li><li>continue ==》跳过本次循环；</li></ol><blockquote><p>for 循环中的变量 i，由于 ES5并没有块级作用域的存在，它在循环结束以后仍然存在于内存中，所以建议使用函数自执行的方式来避免。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。&lt;br&gt;一般我们会采用下几种方式来进行数组的遍历：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;方式1：for-in-循环&quot;&gt;&lt;a href=&quot;#方式1：for-i
      
    
    </summary>
    
      <category term="jQuery" scheme="https://zhipenwang.github.io/categories/jQuery/"/>
    
    
      <category term="Web前端" scheme="https://zhipenwang.github.io/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>js与jquery关于验证页面元素存在的方法及不同之处</title>
    <link href="https://zhipenwang.github.io/2018/05/05/js_3/"/>
    <id>https://zhipenwang.github.io/2018/05/05/js_3/</id>
    <published>2018-05-05T10:35:29.639Z</published>
    <updated>2018-05-05T11:06:10.024Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在javascript中我们可以通过以下代码判断页面中是否存在某个元素</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">obj = document.getElementById(&quot;someID&quot;);</div><div class="line">if (obj) &#123;</div><div class="line">     obj.innerText(&quot;Extsts&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>那么在jQuery，我们如何判断页面元素存在与否呢？如果参照上面的传统Javascript的写法，我们第一个想到的办法会是：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ($(&quot;#someID&quot;))&#123;</div><div class="line">      $(&quot;#someID&quot;).text(&quot;hi&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可是这么写是不对的！因为<strong>jQuery对象永远都有返回值</strong>，所以$(“someID”) 总是TRUE ，IF语句没有起到任何判断作用。<br>我们知道，jQuery选择器获取页面的element时，无论element是否存在，都会返回一个对象。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var my_element = $(&quot;#element_Id&quot; );</div></pre></td></tr></table></figure></p><p>此时的变量my_element就是一个对象，既然是一个对象，这个对象就具有length的属性，因此，用以下代码可以判断元素（对象）是否存在</p><p>正确的写法应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ( $(&quot;#someID&quot;).length &gt; 0 ) &#123;</div><div class="line">     $(&quot;#someID&quot;).text(&quot;Extsts&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>注意 ：判断某个页面元素存在与否在jQuery实际上是没有必要的，jQuery本身会忽略 对一个不存在的元素进行操作，并且不会报错, 所以这么写代码会存在bug。<br>假如不存在someID这个元素，我们照样可以执行一下代码，并不会报错。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var value=$(&apos;#someID&apos;).length;</div><div class="line">if(value&gt;0)&#123;</div><div class="line">     alert(&apos;Extsts&apos;);</div><div class="line">&#125;else&#123;</div><div class="line">      alert(&apos;not Extsts&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>JS判断变量是否为空或是否null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line">* 判断是否null </div><div class="line">* @param data </div><div class="line">*/ </div><div class="line">function isNull(data)&#123; </div><div class="line">return (data == &quot;&quot; || data == undefined || data == null) ? &quot;暂无&quot; : data; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在javascript中我们可以通过以下代码判断页面中是否存在某个元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;di
      
    
    </summary>
    
      <category term="jQuery" scheme="https://zhipenwang.github.io/categories/jQuery/"/>
    
    
      <category term="Web前端" scheme="https://zhipenwang.github.io/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>jQuery对于父子、同级元素的处理方式</title>
    <link href="https://zhipenwang.github.io/2018/05/01/js_2/"/>
    <id>https://zhipenwang.github.io/2018/05/01/js_2/</id>
    <published>2018-05-01T02:48:45.663Z</published>
    <updated>2018-05-01T03:01:56.396Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一节介绍了一些关于表单处理的元素内容<br>本节介绍jquery对于父、同级、子元素的处理方式。</p></blockquote><h3 id="父窗口与子窗口处理"><a href="#父窗口与子窗口处理" class="headerlink" title="父窗口与子窗口处理"></a>父窗口与子窗口处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">父窗口：</div><div class="line">&lt;input name=&apos;img&apos; type=&apos;text&apos; /&gt;</div><div class="line">&lt;img id=&apos;img&apos; src=&apos;&apos; /&gt;</div><div class="line">layer.open(&#123;</div><div class="line">    type: 2,</div><div class="line">    title: &apos;title&apos;,</div><div class="line">    area: [&apos;500px&apos;, &apos;350px&apos;],</div><div class="line">    content &apos;son.html&apos;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">子窗口：</div><div class="line">var img_url;</div><div class="line">parent.$(&quot;input[name=&apos;img&apos;]&quot;).val(img_url);</div><div class="line">parent.$(&apos;#img&apos;).attr(&apos;src&apos;, img_url);</div><div class="line">parent.layer.closeAll();</div></pre></td></tr></table></figure><h2 id="jQuery获取父元素节点、子元素节点及兄弟元素节点的方法"><a href="#jQuery获取父元素节点、子元素节点及兄弟元素节点的方法" class="headerlink" title="jQuery获取父元素节点、子元素节点及兄弟元素节点的方法"></a>jQuery获取父元素节点、子元素节点及兄弟元素节点的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;ul class=&quot;par&quot;&gt;</div><div class="line">&lt;li id=&quot;firstli&quot;&gt;</div><div class="line">&lt;h3 class=&quot;title&quot;&gt;one&lt;/h3&gt;</div><div class="line">&lt;ul class=&quot;par&quot;&gt;</div><div class="line">&lt;li id=&quot;one&quot;&gt;one_first&lt;/li&gt;</div><div class="line">&lt;li&gt;two_first&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure><h3 id="jquery父节点的获取"><a href="#jquery父节点的获取" class="headerlink" title="jquery父节点的获取"></a>jquery父节点的获取</h3><h4 id="使用parent-获取父节点"><a href="#使用parent-获取父节点" class="headerlink" title="使用parent()获取父节点"></a>使用parent()获取父节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&quot;#one&quot;).parent().parent();  // 获取 id为firstli的li标签节点</div><div class="line">$(&quot;#one&quot;).parent().parent(&apos;.par&apos;); // 获取最上面 class为par的ul节点</div><div class="line">$(&quot;#one&quot;).parent(&apos;.par&apos;); // 获取 id为one的上一级class为par的ul节点</div></pre></td></tr></table></figure><h4 id="使用parents-和closest-获取父节点"><a href="#使用parents-和closest-获取父节点" class="headerlink" title="使用parents()和closest()获取父节点"></a>使用parents()和closest()获取父节点</h4><blockquote><ol><li>closest从当前元素开始匹配寻找，逐级向上寻找直到找到匹配的元素后就停止了，返回0或者1个元素</li><li>parents从父元素开始匹配寻找，一直向上查找直到找到根元素，将所有元素放到另外一个集合中，返回0、1或者更多元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(&quot;#one&quot;).parnets(&apos;.par&apos;);  // 找出所有class为par的父节点/父父节点</div><div class="line">$(&quot;one&quot;).closest(&apos;.par&apos;);  // 获取最近一层的父级class为par的ul节点</div></pre></td></tr></table></figure></li></ol></blockquote><h3 id="jquery兄弟节点的获取"><a href="#jquery兄弟节点的获取" class="headerlink" title="jquery兄弟节点的获取"></a>jquery兄弟节点的获取</h3><h4 id="parent父节点再find子节点"><a href="#parent父节点再find子节点" class="headerlink" title="parent父节点再find子节点"></a>parent父节点再find子节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;.title&apos;).parent().find(&apos;ul&apos;);  // 找到class为title的兄弟节点ul，即class为par的ul</div></pre></td></tr></table></figure><h4 id="sibingls-获取兄弟节点"><a href="#sibingls-获取兄弟节点" class="headerlink" title="sibingls()获取兄弟节点"></a>sibingls()获取兄弟节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;.title&apos;).sibings(&apos;ul&apos;);  // 找到class为title的兄弟节点ul，即class为par的ul</div></pre></td></tr></table></figure><h3 id="jquery子节点的获取"><a href="#jquery子节点的获取" class="headerlink" title="jquery子节点的获取"></a>jquery子节点的获取</h3><h4 id="first方式"><a href="#first方式" class="headerlink" title=":first方式"></a>:first方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;.par:first-child&apos;);  // 获取id为firstli的li节点</div></pre></td></tr></table></figure><h4 id="选择器获取"><a href="#选择器获取" class="headerlink" title="选择器获取"></a>选择器获取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;#firstli h3.title&apos;);  // 获取class为title的h3节点</div></pre></td></tr></table></figure><h4 id="find-函数"><a href="#find-函数" class="headerlink" title="find()函数"></a>find()函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;#firstli&apos;).find(&apos;h3&apos;);  // 获取class为title的h3节点</div></pre></td></tr></table></figure><h4 id="children-函数"><a href="#children-函数" class="headerlink" title="children()函数"></a>children()函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;#firstli&apos;).children(&apos;h3.title&apos;);   // 获取class为title的h3节点</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上一节介绍了一些关于表单处理的元素内容&lt;br&gt;本节介绍jquery对于父、同级、子元素的处理方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;父窗口与子窗口处理&quot;&gt;&lt;a href=&quot;#父窗口与子窗口处理&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="jQuery" scheme="https://zhipenwang.github.io/categories/jQuery/"/>
    
    
      <category term="Web前端" scheme="https://zhipenwang.github.io/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>jQuery获取表单值及属性内容</title>
    <link href="https://zhipenwang.github.io/2018/04/21/js_1/"/>
    <id>https://zhipenwang.github.io/2018/04/21/js_1/</id>
    <published>2018-04-21T12:21:01.000Z</published>
    <updated>2018-05-01T03:01:27.933Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>平时前端在处理表单数据的时候，总是需要通过表单属性或者值来进行一些用户看不到的处理。<br>比如：联动选项的处理、数据的验证过滤等。<br>本节针对不同的表单内容进行了不同的获取方式。</p></blockquote><h3 id="获取当前表单元素的值"><a href="#获取当前表单元素的值" class="headerlink" title="获取当前表单元素的值"></a>获取当前表单元素的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;text&quot; name=&quot;name&quot; onblur=&quot;getValue(this)&quot;&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">function getValue(obj)&#123;</div><div class="line">    // 获取值</div><div class="line">$(obj).val();</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h3 id="获取表单元素值及属性内容"><a href="#获取表单元素值及属性内容" class="headerlink" title="获取表单元素值及属性内容"></a>获取表单元素值及属性内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;</div><div class="line">&lt;select name=&quot;sex&quot; data-type=&quot;sex&quot; field=&quot;sex&quot;&gt;</div><div class="line">&lt;option value=&quot;man&quot;&gt;男&lt;/option&gt;</div><div class="line">&lt;option value=&quot;woman&quot;&gt;女&lt;/option&gt;</div><div class="line">&lt;/select&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">function do_submit(obj)&#123;</div><div class="line">    // 获取值</div><div class="line">var name = $(&quot;input[name=&apos;name&apos;]&quot;).val();</div><div class="line">var sex_value = $(&quot;select[name=&apos;sex&apos;]&quot;).val();</div><div class="line">// 获取特定文本值的数据</div><div class="line">    $(&apos;select[name=&quot;data[select]&quot;] [value=&quot;man&quot;]&apos;).val();</div><div class="line">// 获取文本值</div><div class="line">var sex_text = $(&quot;select[name=&apos;sex&apos;]&quot;).find(&apos;option:selected&apos;).text();</div><div class="line">// 获取data-type属性值</div><div class="line">var sex_type = $(&quot;select[name=&apos;sex&apos;]&quot;).data(&apos;type&apos;);</div><div class="line">var sex_type = $(&quot;select[name=&apos;sex&apos;]&quot;).attr(&apos;data-type&apos;);</div><div class="line">// 获取field属性值</div><div class="line">var sex_field = $(&quot;select[name=&apos;sex&apos;]&quot;).attr(&apos;field&apos;);</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h3 id="获取多个多行文本框内容值"><a href="#获取多个多行文本框内容值" class="headerlink" title="获取多个多行文本框内容值"></a>获取多个多行文本框内容值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;textarea name=&quot;formula[]&quot; class=&quot;text&quot;&gt;&lt;/textarea&gt;</div><div class="line">&lt;textarea name=&quot;formula[]&quot; class=&quot;text&quot;&gt;&lt;/textarea&gt;</div><div class="line">&lt;textarea name=&quot;formula[]&quot; class=&quot;text&quot;&gt;&lt;/textarea&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var formula = new Array();</div><div class="line">$(&quot;.text,textarea&quot;).each(function(e)&#123;</div><div class="line">    formula.push($(this).val());</div><div class="line">&#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;平时前端在处理表单数据的时候，总是需要通过表单属性或者值来进行一些用户看不到的处理。&lt;br&gt;比如：联动选项的处理、数据的验证过滤等。&lt;br&gt;本节针对不同的表单内容进行了不同的获取方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;获取当前表
      
    
    </summary>
    
      <category term="jQuery" scheme="https://zhipenwang.github.io/categories/jQuery/"/>
    
    
      <category term="Web前端" scheme="https://zhipenwang.github.io/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>更换电脑后的博客续写</title>
    <link href="https://zhipenwang.github.io/2018/04/04/change_do_hexo/"/>
    <id>https://zhipenwang.github.io/2018/04/04/change_do_hexo/</id>
    <published>2018-04-04T05:21:01.000Z</published>
    <updated>2018-04-05T01:55:07.680Z</updated>
    
    <content type="html"><![CDATA[<p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p><ol><li>使用git clone git@github.com:zhipenwang/zhipenwang.github.io.git拷贝仓库（默认分支为master）；</li><li><p>在本地新拷贝的<a href="http://zhipenwang.github.io文件夹下通过Git" target="_blank" rel="external">http://zhipenwang.github.io文件夹下通过Git</a> bash依次执行下列指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install hexo</div><div class="line">npm install</div><div class="line">npm install hexo-deployer-git</div></pre></td></tr></table></figure><p> （记得，不需要hexo init这条指令）。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用git clone git@github.com:zhipenwang/zhipenwang.github.io.git拷贝仓库（默认分支为master）；&lt;/li&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
      <category term="搭建博客" scheme="https://zhipenwang.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://zhipenwang.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>git 误删分支恢复方法</title>
    <link href="https://zhipenwang.github.io/2018/03/28/git_recover_branch/"/>
    <id>https://zhipenwang.github.io/2018/03/28/git_recover_branch/</id>
    <published>2018-03-28T10:21:01.000Z</published>
    <updated>2018-03-28T11:37:50.382Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在使用git的时候，有时候会因为人为因素导致分支（commit）被删除，可以使用如下步骤进行恢复。</li></ul><h3 id="首先使用以下步骤创建一个新分支，修改一些文件后删除，以便进行恢复"><a href="#首先使用以下步骤创建一个新分支，修改一些文件后删除，以便进行恢复" class="headerlink" title="首先使用以下步骤创建一个新分支，修改一些文件后删除，以便进行恢复"></a>首先使用以下步骤创建一个新分支，修改一些文件后删除，以便进行恢复</h3><p>1、创建分支hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch hexo</div></pre></td></tr></table></figure></p><p>2、查看分支列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git branch -a</div><div class="line">  * master</div><div class="line">hexo</div></pre></td></tr></table></figure></p><p>3、切换到hexo分支，随便修改一下东西后commit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git checkout hexo</div><div class="line"></div><div class="line">echo &apos;hexo&apos; &gt; test.txt</div><div class="line"></div><div class="line">git add .</div><div class="line">git commit -m &apos;add test.txt&apos;</div></pre></td></tr></table></figure></p><p>4、删除分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -D hexo</div></pre></td></tr></table></figure></p><p>5、查看分支列表，hexo分支已经不存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch -a</div><div class="line">  * master</div></pre></td></tr></table></figure></p><h2 id="恢复步骤如下"><a href="#恢复步骤如下" class="headerlink" title="恢复步骤如下"></a>恢复步骤如下</h2><p>1、使用git log -g 找回之前提交的commit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">commit 3eac14d05bc1264cda54a7c21f04c3892f32406a</div><div class="line">Reflog: HEAD@&#123;1&#125; (fdipzone &lt;fdipzone@sina.com&gt;)</div><div class="line">Reflog message: commit: add test.txt</div><div class="line">Author: fdipzone &lt;fdipzone@sina.com&gt;</div><div class="line">Date:   Sun Jan 31 22:26:33 2016 +0800</div><div class="line"></div><div class="line">    add test.txt</div></pre></td></tr></table></figure></p><p>2、使用 git branch recover_branch[新分支] commit_id 命令，用这个commit创建一个分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git branch recover_branch_hexo 3eac14d05bc1264cda54a7c21f04c3892f32406a</div><div class="line"></div><div class="line">git branch -a</div><div class="line">* master</div><div class="line">  recover_branch_hexo</div></pre></td></tr></table></figure></p><p>这个时候，可以看到 recover_branch_hexo分支已经创建了。<br>3、切换到recover_branch_hexo分支，检查文件是否存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout recover_branch_hexo</div><div class="line">ls -lt</div></pre></td></tr></table></figure></p><p>这样就可以恢复误删除的分支了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;在使用git的时候，有时候会因为人为因素导致分支（commit）被删除，可以使用如下步骤进行恢复。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;首先使用以下步骤创建一个新分支，修改一些文件后删除，以便进行恢复&quot;&gt;&lt;a href=&quot;#首先使用以下步骤创建一个新分支，修改
      
    
    </summary>
    
      <category term="GIT" scheme="https://zhipenwang.github.io/categories/GIT/"/>
    
    
      <category term="GIT" scheme="https://zhipenwang.github.io/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>git 配置ssh密钥</title>
    <link href="https://zhipenwang.github.io/2018/03/27/ssh_key/"/>
    <id>https://zhipenwang.github.io/2018/03/27/ssh_key/</id>
    <published>2018-03-27T11:21:01.000Z</published>
    <updated>2018-03-28T12:01:00.926Z</updated>
    
    <content type="html"><![CDATA[<p>在github帐号注册好之后，将项目clone到本地，加入git bash命令。<br>1、输入cd ~/.ssh 回车，查看是否有ssh key密钥，有了就备份</p><p><center><br><img src="/img/ssh_dir.png" alt=""><br></center><br>2、创建ssh key，输入下面命令回车，之后会让你输入github的账号密码，如图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;youremail@youremail.com&quot;</div><div class="line"></div><div class="line">Creates a new ssh key using the provided email # Generating public/private rsa key pair.</div><div class="line"></div><div class="line">Enter file in which to save the key (/home/you/.ssh/id_rsa):</div></pre></td></tr></table></figure></p><p>直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Enter same passphrase again: [Type passphrase again]</div></pre></td></tr></table></figure></p><p>完了之后，大概是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Your public key has been saved in /home/you/.ssh/id_rsa.pub.</div><div class="line">The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com</div></pre></td></tr></table></figure></p><p><center><br><img src="/img/ssh_gen.png" alt=""><br></center><br>3、找到本地id_rsa.pub文件，复制里面的内容，这就是ssh密钥，可以通过pwd命令来查看当前文件位置</p><p><center><br><img src="/img/ssh_pwd.png" alt=""><br></center></p><p><center><br><img src="/img/ssh_key_dir.png" alt=""><br></center><br>4、登录github，在个人中心的setting中，找到 SSH and GPG keys</p><p><center><br><img src="/img/github_ssh.png" alt=""><br></center><br>点击 new ssh key，将复制的ssh密钥粘贴进 “key”文本框，title随便输入即可。<br>点击add key。<br>添加ssh密钥到远程仓库完成。<br>5、验证ssh是否可用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure></p><p>返回如下表示正常可用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi xxx! You&apos;ve successfully authenticated, but GitHub does not # provide shell access.</div></pre></td></tr></table></figure></p><p>6、此时查看你的远程分支地址是否是ssh协议的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git remote -v</div><div class="line">origin https://github.com/zhipenwang/zhipenwang.git (fetch)</div><div class="line">origin https://github.com/zhipenwang/zhipenwang.git (push)</div></pre></td></tr></table></figure></p><p>如果是https协议，修改为ssh协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote set-url origin git@github.com:zhipenwang/zhipenwang.git</div></pre></td></tr></table></figure></p><p>这个时候就可以进行push了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在github帐号注册好之后，将项目clone到本地，加入git bash命令。&lt;br&gt;1、输入cd ~/.ssh 回车，查看是否有ssh key密钥，有了就备份&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;/img/ssh_dir.png&quot; alt=&quot;&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="GIT" scheme="https://zhipenwang.github.io/categories/GIT/"/>
    
    
      <category term="GIT" scheme="https://zhipenwang.github.io/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>初始算法</title>
    <link href="https://zhipenwang.github.io/2018/02/13/algorithm/"/>
    <id>https://zhipenwang.github.io/2018/02/13/algorithm/</id>
    <published>2018-02-13T09:21:01.000Z</published>
    <updated>2018-03-28T10:28:36.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>算法：程序的灵魂</p><p>算法：algorithm</p></blockquote><p>算法五大特征：</p><ul><li>1、有穷性：保证执行有限步骤后结束</li><li>2、确切性：每一步骤都有确切的意义</li><li>3、输入：每个算法都有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身定除了初始条件</li><li>4、输出：每个算法都有一个或多个输出，显示对输入数据加工后的结果。没有输出的算法是毫无意义的</li><li>5、可行性：在原则上算法能够精确地运行，进行优先次运算后即可完成的一种运算。</li></ul><blockquote><p>算法的逻辑、流程。<br>计算机中的算法，分为两大类：数值运算算法（求解数值）、非数值运算算法（事务管理领域）。<br>算法是计算机处理信息的本质，因为计算机程序本质上是一个算法，告诉计算机确切的步骤来执行一个指定的任务。</p><p>著名计算机科学家沃思公式：数据结构+算法=程序。</p></blockquote><p>一个程序应当采用结构化程序设计方法进行程序设计，并且用某一种计算机语言来表示，因此，下面的公式更加贴切：</p><blockquote><p>程序=算法+数据结构+程序设计方法+语言和环境</p></blockquote><h3 id="流程图来表示算法："><a href="#流程图来表示算法：" class="headerlink" title="流程图来表示算法："></a>流程图来表示算法：</h3><p><img src="/img/screenshot_1513006093776.png" alt=""></p><blockquote><p>流程图的结构：顺序结构、选择结构、循环结构</p></blockquote><h3 id="N-S图"><a href="#N-S图" class="headerlink" title="N-S图"></a>N-S图</h3><blockquote><p>N-S流程图：代表计算机的算法。由一些特定意义的图像、流程线及简要的文字说明构成，能够清晰明确的表示程序的运行过程。（整个程序写在一个大框图内，由若干个小的基础框图构成，简称N-S图）</p></blockquote><p><img src="/img/screenshot_1513006588835.png" alt=""></p><h3 id="计算机语言的算法表示"><a href="#计算机语言的算法表示" class="headerlink" title="计算机语言的算法表示"></a>计算机语言的算法表示</h3><p>计算机语言表示算法的时候，必须严格遵循使用语言的语法规则。</p><h3 id="学好算法的秘诀"><a href="#学好算法的秘诀" class="headerlink" title="学好算法的秘诀"></a>学好算法的秘诀</h3><p>1、学的深入，基础扎实<br>2、恒心、演练、举一反三<br>3、语言之争的时代更要学会坚持</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;算法：程序的灵魂&lt;/p&gt;
&lt;p&gt;算法：algorithm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;算法五大特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、有穷性：保证执行有限步骤后结束&lt;/li&gt;
&lt;li&gt;2、确切性：每一步骤都有确切的意义&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="算法与结构" scheme="https://zhipenwang.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://zhipenwang.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="结构" scheme="https://zhipenwang.github.io/tags/%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>composer构建PHP框架——构建路由</title>
    <link href="https://zhipenwang.github.io/2017/04/21/composer-3/"/>
    <id>https://zhipenwang.github.io/2017/04/21/composer-3/</id>
    <published>2017-04-21T11:21:01.000Z</published>
    <updated>2018-03-28T10:28:36.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由选择安装"><a href="#路由选择安装" class="headerlink" title="路由选择安装"></a>路由选择安装</h2><p>本节开始构建路由，先去 GitHub 搜一下：<a href="https://github.com/search?l=PHP&amp;o=desc&amp;q=router&amp;ref=searchresults&amp;s=stars&amp;type=Repositories&amp;utf8=%E2%9C%93" target="_blank" rel="external">点此查看搜索结果</a></p><p>推荐 <a href="https://github.com/NoahBuscher/Macaw" target="_blank" rel="external">https://github.com/NoahBuscher/Macaw</a>，对应的 Composer 包为 noahbuscher/macaw 。</p><p>下面开始安装它，更改 composer.json：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;require&quot;:&#123;</div><div class="line">&quot;noahbuscher/macaw&quot;: &quot;dev-master&quot;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行 composer update，成功之后将得到以下目录：</p><p><center><br><img src="/img/composer-3-1.png" alt=""><br></center><br>至此，Macaw安装成功！</p><h2 id="站点入口文件与环境"><a href="#站点入口文件与环境" class="headerlink" title="站点入口文件与环境"></a>站点入口文件与环境</h2><p>在项目目录下新建public 文件夹，这个文件夹将是用户唯一可见的部分。在文件夹下新建 index.php 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">// Autoload 自动载入</div><div class="line">require &apos;../vendor/autoload.php&apos;;</div><div class="line"></div><div class="line">// 路由配置</div><div class="line">require &apos;../config/routes.php&apos;;</div></pre></td></tr></table></figure></p><p>上面一行表示引入 Composer 的自动载入功能，下面一行表示载入路由配置文件。<br>然后继续在项目目录下新建config文件夹，在config文件夹内新建 routs.php 文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">use NoahBuscher\Macaw\Macaw;</div><div class="line"></div><div class="line">Macaw::get(&apos;fuck&apos;, function() &#123;</div><div class="line">  echo &quot;成功！&quot;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Macaw::get(&apos;(:all)&apos;, function($fu) &#123;</div><div class="line">  echo &apos;未匹配到路由&lt;br&gt;&apos;.$fu;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Macaw::dispatch();</div></pre></td></tr></table></figure></p><p>然后访问你的地址即可：<a href="http://127.0.0.66/index.php/fuck" target="_blank" rel="external">http://127.0.0.66/index.php/fuck</a></p><p>注意：如果要配置域名地址进行映射要指向 <code>public/index.php</code> 文件<br><img src="/img/composer-3-2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路由选择安装&quot;&gt;&lt;a href=&quot;#路由选择安装&quot; class=&quot;headerlink&quot; title=&quot;路由选择安装&quot;&gt;&lt;/a&gt;路由选择安装&lt;/h2&gt;&lt;p&gt;本节开始构建路由，先去 GitHub 搜一下：&lt;a href=&quot;https://github.com/sea
      
    
    </summary>
    
      <category term="composer使用" scheme="https://zhipenwang.github.io/categories/composer%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Composer" scheme="https://zhipenwang.github.io/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>composer安装与使用</title>
    <link href="https://zhipenwang.github.io/2017/04/21/composer-1/"/>
    <id>https://zhipenwang.github.io/2017/04/21/composer-1/</id>
    <published>2017-04-21T11:21:01.000Z</published>
    <updated>2018-03-28T10:28:36.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、点击下载：<a href="https://getcomposer.org/download/" target="_blank" rel="external">composer</a></p><center><br><img src="/img/composer-1-1.png" alt=""><br></center><br>2、下载好之后双击直接安装，Next即可：<br><br><center><br><img src="/img/composer-1-2.png" alt=""><br></center><br>3、然后选择php.exe文件：<br><br><center><br><img src="/img/composer-1-3.png" alt=""><br></center><p>接下来就一直next到安装完成即可。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>[info]使用composer安装ThinkPHP5</p></blockquote><p>通过<a href="https://pkg.phpcomposer.com/" target="_blank" rel="external">composer中国镜像</a>进行初步了解<br><img src="/img/composer-1-4.png" alt=""></p><p>##开始命令行操作</p><h3 id="1、中国镜像下载"><a href="#1、中国镜像下载" class="headerlink" title="1、中国镜像下载"></a>1、中国镜像下载</h3><p>参考<a href="http://www.kancloud.cn/thinkphp/thinkphp5_quickstart/145249" target="_blank" rel="external">tp5看云文档</a></p><p>由于国外网站访问很慢，国内提供了很好的镜像，所以使用国内镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Composer config -g repo.packagist composer https://packagist.phpcomposer.com</div></pre></td></tr></table></figure></p><p><img src="/img/composer-1-5.png" alt=""></p><h3 id="2、下载tp5框架"><a href="#2、下载tp5框架" class="headerlink" title="2、下载tp5框架"></a>2、下载tp5框架</h3><p>进入站点根目录www操作命令行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer create-project topthink/think tp5  --prefer-dist</div></pre></td></tr></table></figure></p><p>其中tp5可写填写任何你愿意的名称<br><img src="/img/composer-1-6.png" alt=""></p><h2 id="框架安装完成"><a href="#框架安装完成" class="headerlink" title="框架安装完成"></a>框架安装完成</h2><p>耐心等待几分钟的安装过程，安装完成之后本地已经生成了tp5的新框架内容<br><img src="/img/composer-1-7.png" alt=""></p><h2 id="composer主要的功能：安装扩展包"><a href="#composer主要的功能：安装扩展包" class="headerlink" title="composer主要的功能：安装扩展包"></a>composer主要的功能：安装扩展包</h2><p>composer的最主要的功能：dependency manager for PHP<br>进入项目目录tp5，执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer require riverslei/payment</div></pre></td></tr></table></figure></p><p>下载riverslei/payment 集成支付宝、微信支付等流行的支付接口到项目中：<br>Composer.json中新增了这一句：<br><img src="/img/composer-1-8.png" alt=""></p><p>项目目录中也已经安装好了扩展包：<br><img src="/img/composer-1-9.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;1、点击下载：&lt;a href=&quot;https://getcomposer.org/download/&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="composer使用" scheme="https://zhipenwang.github.io/categories/composer%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Composer" scheme="https://zhipenwang.github.io/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>composer构建PHP框架——初始化</title>
    <link href="https://zhipenwang.github.io/2017/04/21/composer-2/"/>
    <id>https://zhipenwang.github.io/2017/04/21/composer-2/</id>
    <published>2017-04-21T11:21:01.000Z</published>
    <updated>2018-03-28T10:28:36.135Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“一个时代结束了，另一个时代开始了。”<br>Framework Interoperability Group（框架可互用性小组），简称 FIG，成立于 2009 年。FIG 最初由几位知名 PHP 框架开发者发起，在吸纳了许多优秀的大脑和强健的体魄后，提出了 PSR-0 到 PSR-4 五套 PHP 非官方规范：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">* PSR-0 (Autoloading Standard) 自动加载标准</div><div class="line"></div><div class="line">* PSR-1 (Basic Coding Standard) 基础编码标准</div><div class="line"></div><div class="line">* PSR-2 (Coding Style Guide) 编码风格向导</div><div class="line"></div><div class="line">* PSR-3 (Logger Interface) 日志接口</div><div class="line"></div><div class="line">* PSR-4 (Improved Autoloading) 自动加载优化标准</div></pre></td></tr></table></figure><h3 id="创建composer-json"><a href="#创建composer-json" class="headerlink" title="创建composer.json"></a>创建composer.json</h3><p>在网站根目录下创建新文件夹 <code>my-framework</code> （My First Framework based on Composer），然后在此文件夹内创建 <code>composer.json</code> 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;require&quot;:&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="初始化composer"><a href="#初始化composer" class="headerlink" title="初始化composer"></a>初始化composer</h3><p>打开命令行cmd，进入刚刚新建的目录 <code>my_framework</code>，执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer update</div></pre></td></tr></table></figure></p><p>执行成功后生成了扩展包<code>vendor</code></p><center><br><img src="/img/composer-2-1.png" alt=""><br></center><br>此时目录为：<br><center><br><img src="/img/composer-2-2.png" alt=""><br></center><p>到此，composer初始化完成！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;“一个时代结束了，另一个时代开始了。”&lt;br&gt;Framework Interoperability Group（框架可互用性小组），简称 FIG，成立于 2009 年。FIG 最初由几位知名 PHP 框架开发者发起，在吸纳了许多优秀的大脑和强健的体
      
    
    </summary>
    
      <category term="composer使用" scheme="https://zhipenwang.github.io/categories/composer%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Composer" scheme="https://zhipenwang.github.io/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>Hexo NexT主题内接入网页在线联系功能</title>
    <link href="https://zhipenwang.github.io/2017/04/20/connect/"/>
    <id>https://zhipenwang.github.io/2017/04/20/connect/</id>
    <published>2017-04-20T11:12:49.000Z</published>
    <updated>2018-03-28T10:28:36.137Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo博客如何添加在线联系功能呢,发现了一个不错的网站可以提供在线联系的服务，当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>首先在(DaoVoice)[<a href="http://www.daovoice.io/]注册个账号。" target="_blank" rel="external">http://www.daovoice.io/]注册个账号。</a><br>登录上去之后进行配置，配置方法如下:<br>首先到DaoVoice上注册一个账号,注册完成后会得到一个app_id，获取appid的步骤如下图所示:<br><img src="/img/daovoice.png" alt=""></p><p>以next主题为例,打开/themes/next/layout/_partials/head.swig文件添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;% if theme.daovoice %&#125;</div><div class="line">  &lt;script&gt;</div><div class="line">  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;)</div><div class="line">  daovoice(&apos;init&apos;, &#123;</div><div class="line">      app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot;</div><div class="line">    &#125;);</div><div class="line">  daovoice(&apos;update&apos;);</div><div class="line">  &lt;/script&gt;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p><p>接着打开主题配置文件_config.yml，添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Online contact </div><div class="line">daovoice: true</div><div class="line">daovoice_app_id: 这里输入前面获取的app_id</div></pre></td></tr></table></figure></p><p>需要注意的是,next主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置:<br><img src="/img/chat.png" alt=""><br>最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，就可以实时收发消息，有新的消息也会通过微信通知，设置页面如下:<br><img src="/img/wechat.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hexo博客如何添加在线联系功能呢,发现了一个不错的网站可以提供在线联系的服务，当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。&lt;/p&gt;
&lt;h3 id=&quot;注册&quot;&gt;&lt;a href=&quot;#注册&quot; class=&quot;headerlink&quot; title=&quot;注
      
    
    </summary>
    
      <category term="搭建博客" scheme="https://zhipenwang.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://zhipenwang.github.io/tags/hexo/"/>
    
      <category term="next" scheme="https://zhipenwang.github.io/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>Hexo添加字数统计、阅读时长、浏览次数</title>
    <link href="https://zhipenwang.github.io/2017/04/19/blog_view/"/>
    <id>https://zhipenwang.github.io/2017/04/19/blog_view/</id>
    <published>2017-04-19T11:21:01.000Z</published>
    <updated>2018-03-28T10:28:36.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="统计插件"><a href="#统计插件" class="headerlink" title="统计插件"></a>统计插件</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>NexT 主题默认已经集成了文章【浏览次数】、【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要修改主题配置文件 _config.yml 即可。如下所示：<br>配置浏览次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">busuanzi_count:</div><div class="line">  # count values only if the other configs are false</div><div class="line">  enable: true</div><div class="line">  # custom uv span for the whole site</div><div class="line">  site_uv: true</div><div class="line">  site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访问人数</div><div class="line">  site_uv_footer:</div><div class="line">  # custom pv span for the whole site</div><div class="line">  site_pv: true</div><div class="line">  site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 总访问量</div><div class="line">  site_pv_footer:</div><div class="line">  # custom pv span for one page only</div><div class="line">  page_pv: true</div><div class="line">  page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 浏览</div><div class="line">  page_pv_footer: 次</div></pre></td></tr></table></figure></p><p>配置字数统计、阅读时长，wordcount与min2read统计功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># Post wordcount display settings</div><div class="line"># Dependencies: https://github.com/willin/hexo-wordcount</div><div class="line">post_wordcount:</div><div class="line">  item_text: true</div><div class="line">  wordcount: true         # 单篇 字数统计</div><div class="line">  min2read: true          # 单篇 阅读时长</div><div class="line">  totalcount: false       # 网站 字数统计</div><div class="line">  separated_meta: true</div></pre></td></tr></table></figure></p><p>预览的时候如果出现字数统计和阅读时长失效的情况，一般是因为没有安装 hexo-wordcount 插件，查看 Hexo 插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hexo --debug</div><div class="line">``</div><div class="line">### 安装</div><div class="line"></div><div class="line">如果没有安装 hexo-wordcount 插件，先安装该插件：</div></pre></td></tr></table></figure></p><p>npm i –save hexo-wordcount<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*** Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下：***</div></pre></td></tr></table></figure></p><p>npm install hexo-wordcount@2 –save<br>```<br>安装完成后，重新执行启动服务预览就可以了。</p><h3 id="显示文字"><a href="#显示文字" class="headerlink" title="显示文字"></a>显示文字</h3><p>打开<code>post.swig</code>文件，路径如下：<code>xxx_blog/themes/next/layout/_macro/post.swig</code></p><p><img src="/img/view_count.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;统计插件&quot;&gt;&lt;a href=&quot;#统计插件&quot; class=&quot;headerlink&quot; title=&quot;统计插件&quot;&gt;&lt;/a&gt;统计插件&lt;/h2&gt;&lt;h3 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h
      
    
    </summary>
    
      <category term="搭建博客" scheme="https://zhipenwang.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://zhipenwang.github.io/tags/hexo/"/>
    
      <category term="next" scheme="https://zhipenwang.github.io/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>Hexo NexT主题内给每篇文章后添加结束标语</title>
    <link href="https://zhipenwang.github.io/2017/04/18/hexo_next_end/"/>
    <id>https://zhipenwang.github.io/2017/04/18/hexo_next_end/</id>
    <published>2017-04-18T11:21:01.000Z</published>
    <updated>2018-03-28T10:28:36.138Z</updated>
    
    <content type="html"><![CDATA[<p>给文章后面添加结束标语</p><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>在<code>\themes\next\layout\_macro</code>中新建<code>passage-end-tag.swig</code>文件，添加代码至该文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    &#123;% if not is_index %&#125;</div><div class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:22px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</div><div class="line">    &#123;% endif %&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p><h3 id="修改post-swig"><a href="#修改post-swig" class="headerlink" title="修改post.swig"></a>修改post.swig</h3><p>打开\themes\next\layout_macro\post.swig文件，在post-body后，post-footer前，添加下面内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &#123;% if not is_index %&#125;</div><div class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</div><div class="line">  &#123;% endif %&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p><h3 id="修改-config"><a href="#修改-config" class="headerlink" title="修改_config"></a>修改_config</h3><p>打开主题配置文件（_config.yml),在末尾添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 文章末尾添加“本文结束”标记</div><div class="line">passage_end_tag:</div><div class="line">  enabled: true</div></pre></td></tr></table></figure></p><p>至此，就完成了关于添加文章结束标语的功能，具体的效果，此刻，想必你也看到了，就在下边。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给文章后面添加结束标语&lt;/p&gt;
&lt;h3 id=&quot;新建文件&quot;&gt;&lt;a href=&quot;#新建文件&quot; class=&quot;headerlink&quot; title=&quot;新建文件&quot;&gt;&lt;/a&gt;新建文件&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;\themes\next\layout\_macro&lt;/code&gt;中新建
      
    
    </summary>
    
      <category term="搭建博客" scheme="https://zhipenwang.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://zhipenwang.github.io/tags/hexo/"/>
    
      <category term="next" scheme="https://zhipenwang.github.io/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>Hexo NexT主题添加点击爱心效果</title>
    <link href="https://zhipenwang.github.io/2017/04/17/clickheart/"/>
    <id>https://zhipenwang.github.io/2017/04/17/clickheart/</id>
    <published>2017-04-17T11:21:01.000Z</published>
    <updated>2018-03-28T10:28:36.134Z</updated>
    
    <content type="html"><![CDATA[<p>给NexT主题内添加页面点击出现爱心的效果</p><h3 id="创建js文件"><a href="#创建js文件" class="headerlink" title="创建js文件"></a>创建js文件</h3><p>在<code>/themes/next/source/js/src</code>下新建文件<code>clicklove.js</code>，接着把该<a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js" target="_blank" rel="external">链接</a>下的代码拷贝粘贴到<code>clicklove.js</code>文件中。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</div></pre></td></tr></table></figure></p><h3 id="修改-layout-swig"><a href="#修改-layout-swig" class="headerlink" title="修改_layout.swig"></a>修改_layout.swig</h3><p>在<code>\themes\next\layout\_layout.swig</code>文件末尾添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 页面点击小红心 --&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给NexT主题内添加页面点击出现爱心的效果&lt;/p&gt;
&lt;h3 id=&quot;创建js文件&quot;&gt;&lt;a href=&quot;#创建js文件&quot; class=&quot;headerlink&quot; title=&quot;创建js文件&quot;&gt;&lt;/a&gt;创建js文件&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;/themes/next/sourc
      
    
    </summary>
    
      <category term="搭建博客" scheme="https://zhipenwang.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://zhipenwang.github.io/tags/hexo/"/>
    
      <category term="next" scheme="https://zhipenwang.github.io/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>hexo发布文章</title>
    <link href="https://zhipenwang.github.io/2017/03/19/hexo_new_blog/"/>
    <id>https://zhipenwang.github.io/2017/03/19/hexo_new_blog/</id>
    <published>2017-03-19T10:21:01.000Z</published>
    <updated>2018-03-28T12:22:07.667Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在部署和搭建好hexo博客后，怎么写好一篇博客并发布到在线地址呢？</li></ul><p>1、找到你本地的博客地址，在source/_posts目录下新建新文件，后缀为md，写一篇markdown文章<br>2、打开git bash命令端<br>本地预览：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server</div></pre></td></tr></table></figure></p><p>提交到git仓库，同步到在线博客<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate</div><div class="line">hexo deploy</div></pre></td></tr></table></figure></p><p>然后就可以在你的博客看到更新的文章了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;在部署和搭建好hexo博客后，怎么写好一篇博客并发布到在线地址呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1、找到你本地的博客地址，在source/_posts目录下新建新文件，后缀为md，写一篇markdown文章&lt;br&gt;2、打开git bash命令端&lt;br&gt;本地预览：
      
    
    </summary>
    
      <category term="搭建博客" scheme="https://zhipenwang.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Article" scheme="https://zhipenwang.github.io/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>github+hexo搭建个人博客</title>
    <link href="https://zhipenwang.github.io/2017/03/18/create-blog/"/>
    <id>https://zhipenwang.github.io/2017/03/18/create-blog/</id>
    <published>2017-03-18T11:21:01.000Z</published>
    <updated>2018-03-28T10:28:36.137Z</updated>
    
    <content type="html"><![CDATA[<p><strong>各位有兴趣搭建博客或者正在搭建博客却遇到问题的朋友们，不妨抽空来围观一下我搭建的过程中遇到的坑和填的土。。</strong></p><p><em>声明一点，以下所有步骤都是基于Windows系统的搭建，由于本人没有真正在其他系统上搭建过，就不画蛇添足了，所以其他系统的小心不要入错入坑咯</em></p><p>下面先说一下基本思路（给大家一个清晰的搭建过程）：</p><blockquote><p>1、在Windows系统下搭建运行hexo环境的前提是先搭建<strong>nodejs</strong>跟<strong>git</strong><br>2、搭建好nodejs跟git后就可以在系统中搭建hexo环境<br>3、申请github.com帐号，创建自己的repository（仓库）——注意仓库名必须是：yourusername.github.io，具体原因及内容后面细讲、<br>4、本地hexo环境部署到github上 5、yourusername.github.io查看自己的博客，成功！</p></blockquote><h3 id="第一步：搭建nodejs环境"><a href="#第一步：搭建nodejs环境" class="headerlink" title="第一步：搭建nodejs环境"></a>第一步：搭建nodejs环境</h3><p>参考菜鸟教程的nodejs，很是详细：<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="external">nodejs-菜鸟教程</a></p><p>大家可以去<a href="https://nodejs.org/en/download/" target="_blank" rel="external">nodejs</a>官网下载，记得要下载跟自己Windows系统一致的版本。（64bit的下载window-install的64-bit；同理：32bit的下载32-bit的）。<br>下载之后双击安装，选择自己要安装的路径地址，一直next到finish就可以了<br><img src="/img/install-node-msi-version-on-windows-step5.png" alt=""><br>安装后检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入”cmd” =&gt; 输入命令”path”，输出结果中有nodejs的环境变量说明安装成功。（如下我的环境变量已经有nodejs了）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PATH=C:\oraclexe\app\oracle\product\10.2.0\server\bin;C:\Windows\system32;</div><div class="line">C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;</div><div class="line">c:\python32\python;C:\MinGW\bin;C:\Program Files\GTK2-Runtime\lib;</div><div class="line">C:\Program Files\MySQL\MySQL Server 5.5\bin;C:\Program Files\nodejs\;</div></pre></td></tr></table></figure></p><p>然后可以检查一下Node.js版本，直接命令行输入 node –version<br><img src="/img/node-version.png" alt=""><br>ok，nodejs环境到此完成。</p><h3 id="第二步：搭建GIT环境"><a href="#第二步：搭建GIT环境" class="headerlink" title="第二步：搭建GIT环境"></a>第二步：搭建GIT环境</h3><p>同样，大家可以参考<a href="http://jingyan.baidu.com/article/90895e0fb3495f64ed6b0b50.html" target="_blank" rel="external">百度经验</a></p><p>下载地址可以前往<a href="http://msysgit.github.io/" target="_blank" rel="external">git官网</a>进行下载，同样下载跟自己系统位数一致的版本<br>下载之后双击选择自己要安装的路径地址一键next安装就好了<br><img src="/img/git-install.jpg" alt=""><br>安装好之后在任意位置右键都可以看到关于git的一些菜单选项：<br><img src="/img/git_menu.png" alt=""><br>ok，至此git安装完成。</p><h3 id="第三步：搭建hexo环境"><a href="#第三步：搭建hexo环境" class="headerlink" title="第三步：搭建hexo环境"></a>第三步：搭建hexo环境</h3><p>在E盘下建立hexo文件夹（或者你选择的任何路径）<br>在nodejs和git环境都搭建完成后，在刚刚建立好的hexo文件夹中点击鼠标右键，选择<strong>git bash</strong>，<br>输入以下命令安装hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo</div></pre></td></tr></table></figure></p><p>接下来是比较重要的步骤，都是在git bash命令行操作，要认真看清楚：</p><ul><li>1、初始化你的博客<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init</div></pre></td></tr></table></figure></li></ul><blockquote><p>执行后hexo会在你的站点目录下生成网站所需的文件</p></blockquote><ul><li>2、安装node_modules：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure></li></ul><blockquote><p>在此目录中生成node_modules</p></blockquote><ul><li>3、本地浏览器查看：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server  (此命令也可以简写为 hexo s)</div></pre></td></tr></table></figure></li></ul><blockquote><p>这时候会出现如下信息：<br>[info] Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>.<br>Press Ctrl+C to stop. </p></blockquote><p>这个时候在你的浏览器输入<a href="http://localhost:4000/你就可以看到本地的博客搭建成功。" target="_blank" rel="external">http://localhost:4000/你就可以看到本地的博客搭建成功。</a><br>这个时候可以轻松一下，随便浏览一下自己的博客熟悉一下</p><h3 id="第四步：本地hexo部署到github上"><a href="#第四步：本地hexo部署到github上" class="headerlink" title="第四步：本地hexo部署到github上"></a>第四步：本地hexo部署到github上</h3><p>1、首先要有github帐号，可以前往<a href="http://www.github.com/" target="_blank" rel="external">github官网</a>注册一个自己的github帐号，登录成功后，点击右上角的+号新建一个仓库<br><img src="/img/new_repository.png" alt=""><br>注意，仓库名必须跟自己的username一致，格式是username.github.io<br><img src="/img/username_git.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;各位有兴趣搭建博客或者正在搭建博客却遇到问题的朋友们，不妨抽空来围观一下我搭建的过程中遇到的坑和填的土。。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;声明一点，以下所有步骤都是基于Windows系统的搭建，由于本人没有真正在其他系统上搭建过，就不画蛇添足了，所
      
    
    </summary>
    
      <category term="搭建博客" scheme="https://zhipenwang.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Article" scheme="https://zhipenwang.github.io/tags/Article/"/>
    
  </entry>
  
  <entry>
    <title>博客的意义</title>
    <link href="https://zhipenwang.github.io/2017/03/17/blog/"/>
    <id>https://zhipenwang.github.io/2017/03/17/blog/</id>
    <published>2017-03-17T11:21:01.000Z</published>
    <updated>2018-03-28T10:28:36.133Z</updated>
    
    <content type="html"><![CDATA[<p><em>文中内容仅是个人观点，不喜随便喷，如有雷同，欢迎交流</em></p><h2 id="为什么有开博客的想法呢？"><a href="#为什么有开博客的想法呢？" class="headerlink" title="为什么有开博客的想法呢？"></a>为什么有开博客的想法呢？</h2><p>作为一名后端攻城狮，在各种“撸码”的过程中经常会碰到一些萝卜坑，当然及时植入了萝卜。开始填的时候也不以为常，管他下次会不会被挖再露出坑，慢慢学习的过程中遇到了更多的坑，觉得有点烧闹了，开始各种方式去学着记录，D、E、F盘塞了各种记录文本，慢慢发现这种方式查阅起来很是麻烦，而且最关键的是，有一次打开我记录了几千行的笔记，结果发现乱码了（原因是一直用gbk去写的，某一次脑短路用了默认utf格式的编辑器打开，整篇文档都乱码，又手贱的去直接在编辑器中点错了其他格式还保存，果然是自作孽不可活），后来各种软件编辑器尝试，越来越不认识其字符了，不过对咱来说，没法补救的东西失去了那就从头再来呗。这个时候开始打算换一种方式来记录一些自己遇到的坑和一些有价值的内容，同时也可以在一个平台上跟其他有深度的人沟通学习成长，所以打算在大平台去搭建一个属于个人的主页。</p><p>其中， 新浪博客、QQ空间、CSDN等“个人主页”都流行很久了，所以有越来越多的人开始考虑搭建一个真正属于自己的“个人主页”，个人博客建站也越来越流行。<br>那么搭建个人博客的目的无非是以下几点：</p><blockquote><ul><li>作为一个展示个性的平台<br>搭建一个展示个人观点、爱好、经历的良好平台，跟那些流行的新浪博客和QQ空间不一样，个人博客可以很灵活自由的去设计ownerstyle的网站。</li><li>作为一个知识积累的海洋<br>不管是从事文学、管理、IT开发，都可以通过这个平台去记录一些有价值对自己有影响的内容，积累成一个属于自己知识的海洋</li><li>作为一个交流分享的平台<br>不仅仅把自己的知识积累下来，更大程度的去分享，了解别人的一些不同看法，沟通完善一些自我的缺陷，学习别人更广的知识</li></ul></blockquote><p>作为一个攻城狮，要时刻去接触互联网新的思想，去真正参与到互联网中，既然决定了写博客，那么自己动手去搭建一个专属的博客，然后一步步去推广，不仅仅会带来前进的动力，其实也会慢慢去接触学习到什么才是真正的SEO（搜索引擎–百度搜索排行其实很大程度就是靠这个），也会去认识到网络推广。<br>对目前的我而言，那就是希望坚持下去，作为一个自我价值的体现，在未来的工作或者社交中能够以这个平台去让别人了解自己，成为自我的一个标识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;文中内容仅是个人观点，不喜随便喷，如有雷同，欢迎交流&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么有开博客的想法呢？&quot;&gt;&lt;a href=&quot;#为什么有开博客的想法呢？&quot; class=&quot;headerlink&quot; title=&quot;为什么有开博客的想法呢？&quot;&gt;&lt;/a&gt;为什么有开博客
      
    
    </summary>
    
      <category term="博客思维" scheme="https://zhipenwang.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="Article" scheme="https://zhipenwang.github.io/tags/Article/"/>
    
  </entry>
  
</feed>
